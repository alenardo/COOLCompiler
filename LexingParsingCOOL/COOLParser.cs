//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g 2018-04-12 16:26:28

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using LexingParsingCOOL;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class COOLParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ARROBA", "ASSIGNMENT_LIST", "ASSING", "ATTRIBUTE", "BLOCK", "BODY", "BOOLEAN", "CASE", "CASEBRANCH", "CASEBRANCHES", "CHAR", "CLASS", "CL_LLAVE", "CL_PARENT", "COMA", "COMMENT", "CONDITION", "DIGIT", "DISPATCH", "DIV", "DOUBLEP", "ELSE", "END", "EQ", "ESAC", "ESC_SEQ", "EXPONENT", "FI", "G", "GEQ", "HEX_DIGIT", "ID", "IF", "IMPLICS", "IN", "INHERITS", "ISVOID", "L", "LEQ", "LET", "LOOP", "LOWERCASE", "METHOD", "METHODEFINITION", "MINUS", "MULT", "NANARITA", "NEW", "NL", "NOT", "NUMBER", "OCTAL_ESC", "OF", "OP_LLAVE", "OP_PARENT", "PARAM", "PARAMLIST", "PLUS", "PNT", "POOL", "PROGRAM", "STRING", "THEN", "TYPE", "UNICODE_ESC", "UPERCASE", "VAR_DECLARATION", "VAR_DECLARATION_LIST", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int ARROBA=4;
	public const int ASSIGNMENT_LIST=5;
	public const int ASSING=6;
	public const int ATTRIBUTE=7;
	public const int BLOCK=8;
	public const int BODY=9;
	public const int BOOLEAN=10;
	public const int CASE=11;
	public const int CASEBRANCH=12;
	public const int CASEBRANCHES=13;
	public const int CHAR=14;
	public const int CLASS=15;
	public const int CL_LLAVE=16;
	public const int CL_PARENT=17;
	public const int COMA=18;
	public const int COMMENT=19;
	public const int CONDITION=20;
	public const int DIGIT=21;
	public const int DISPATCH=22;
	public const int DIV=23;
	public const int DOUBLEP=24;
	public const int ELSE=25;
	public const int END=26;
	public const int EQ=27;
	public const int ESAC=28;
	public const int ESC_SEQ=29;
	public const int EXPONENT=30;
	public const int FI=31;
	public const int G=32;
	public const int GEQ=33;
	public const int HEX_DIGIT=34;
	public const int ID=35;
	public const int IF=36;
	public const int IMPLICS=37;
	public const int IN=38;
	public const int INHERITS=39;
	public const int ISVOID=40;
	public const int L=41;
	public const int LEQ=42;
	public const int LET=43;
	public const int LOOP=44;
	public const int LOWERCASE=45;
	public const int METHOD=46;
	public const int METHODEFINITION=47;
	public const int MINUS=48;
	public const int MULT=49;
	public const int NANARITA=50;
	public const int NEW=51;
	public const int NL=52;
	public const int NOT=53;
	public const int NUMBER=54;
	public const int OCTAL_ESC=55;
	public const int OF=56;
	public const int OP_LLAVE=57;
	public const int OP_PARENT=58;
	public const int PARAM=59;
	public const int PARAMLIST=60;
	public const int PLUS=61;
	public const int PNT=62;
	public const int POOL=63;
	public const int PROGRAM=64;
	public const int STRING=65;
	public const int THEN=66;
	public const int TYPE=67;
	public const int UNICODE_ESC=68;
	public const int UPERCASE=69;
	public const int VAR_DECLARATION=70;
	public const int VAR_DECLARATION_LIST=71;
	public const int WHILE=72;
	public const int WS=73;

	public COOLParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public COOLParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return COOLParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:43:9: public program : ( class )+ EOF -> ^( PROGRAM ( class )+ ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<COOLCommonTree, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken EOF2 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> class1 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree EOF2_tree = default(COOLCommonTree);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_class=new RewriteRuleSubtreeStream(adaptor,"rule class");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(43, 51);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:43:16: ( ( class )+ EOF -> ^( PROGRAM ( class )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:43:18: ( class )+ EOF
			{
			DebugLocation(43, 18);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:43:18: ( class )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==CLASS))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:43:19: class
					{
					DebugLocation(43, 19);
					PushFollow(Follow._class_in_program94);
					class1=@class();
					PopFollow();

					stream_class.Add(class1.Tree);

					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(43, 27);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_program98);  
			stream_EOF.Add(EOF2);



			{
			// AST REWRITE
			// elements: class
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (COOLCommonTree)adaptor.Nil();
			// 43:30: -> ^( PROGRAM ( class )+ )
			{
				DebugLocation(43, 32);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:43:32: ^( PROGRAM ( class )+ )
				{
				COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
				DebugLocation(43, 34);
				root_1 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(PROGRAM, "PROGRAM"), root_1);

				DebugLocation(43, 42);
				if (!(stream_class.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_class.HasNext )
				{
					DebugLocation(43, 43);
					adaptor.AddChild(root_1, stream_class.NextTree());

				}
				stream_class.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(43, 51);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_class();
	partial void LeaveRule_class();

	// $ANTLR start "class"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:2: class : ( CLASS ^ TYPE ( INHERITS TYPE )? OP_LLAVE ! ( feature_list )? CL_LLAVE ! END !) ;
	[GrammarRule("class")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> @class()
	{
		EnterRule_class();
		EnterRule("class", 2);
		TraceIn("class", 2);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken CLASS3 = default(IToken);
		IToken TYPE4 = default(IToken);
		IToken INHERITS5 = default(IToken);
		IToken TYPE6 = default(IToken);
		IToken OP_LLAVE7 = default(IToken);
		IToken CL_LLAVE9 = default(IToken);
		IToken END10 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> feature_list8 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree CLASS3_tree = default(COOLCommonTree);
		COOLCommonTree TYPE4_tree = default(COOLCommonTree);
		COOLCommonTree INHERITS5_tree = default(COOLCommonTree);
		COOLCommonTree TYPE6_tree = default(COOLCommonTree);
		COOLCommonTree OP_LLAVE7_tree = default(COOLCommonTree);
		COOLCommonTree CL_LLAVE9_tree = default(COOLCommonTree);
		COOLCommonTree END10_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "class");
		DebugLocation(45, 2);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:7: ( ( CLASS ^ TYPE ( INHERITS TYPE )? OP_LLAVE ! ( feature_list )? CL_LLAVE ! END !) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:9: ( CLASS ^ TYPE ( INHERITS TYPE )? OP_LLAVE ! ( feature_list )? CL_LLAVE ! END !)
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(45, 9);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:9: ( CLASS ^ TYPE ( INHERITS TYPE )? OP_LLAVE ! ( feature_list )? CL_LLAVE ! END !)
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:10: CLASS ^ TYPE ( INHERITS TYPE )? OP_LLAVE ! ( feature_list )? CL_LLAVE ! END !
			{
			DebugLocation(45, 15);
			CLASS3=(IToken)Match(input,CLASS,Follow._CLASS_in_class117); 
			CLASS3_tree = (COOLCommonTree)adaptor.Create(CLASS3);
			root_0 = (COOLCommonTree)adaptor.BecomeRoot(CLASS3_tree, root_0);
			DebugLocation(45, 17);
			TYPE4=(IToken)Match(input,TYPE,Follow._TYPE_in_class120); 
			TYPE4_tree = (COOLCommonTree)adaptor.Create(TYPE4);
			adaptor.AddChild(root_0, TYPE4_tree);
			DebugLocation(45, 22);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:22: ( INHERITS TYPE )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==INHERITS))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:23: INHERITS TYPE
				{
				DebugLocation(45, 23);
				INHERITS5=(IToken)Match(input,INHERITS,Follow._INHERITS_in_class123); 
				INHERITS5_tree = (COOLCommonTree)adaptor.Create(INHERITS5);
				adaptor.AddChild(root_0, INHERITS5_tree);
				DebugLocation(45, 32);
				TYPE6=(IToken)Match(input,TYPE,Follow._TYPE_in_class125); 
				TYPE6_tree = (COOLCommonTree)adaptor.Create(TYPE6);
				adaptor.AddChild(root_0, TYPE6_tree);

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(45, 47);
			OP_LLAVE7=(IToken)Match(input,OP_LLAVE,Follow._OP_LLAVE_in_class129); 
			DebugLocation(45, 49);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:49: ( feature_list )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==ID))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:51: feature_list
				{
				DebugLocation(45, 51);
				PushFollow(Follow._feature_list_in_class134);
				feature_list8=feature_list();
				PopFollow();

				adaptor.AddChild(root_0, feature_list8.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(45, 74);
			CL_LLAVE9=(IToken)Match(input,CL_LLAVE,Follow._CL_LLAVE_in_class138); 
			DebugLocation(45, 79);
			END10=(IToken)Match(input,END,Follow._END_in_class141); 

			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("class", 2);
			LeaveRule("class", 2);
			LeaveRule_class();
		}
		DebugLocation(46, 2);
		} finally { DebugExitRule(GrammarFileName, "class"); }
		return retval;

	}
	// $ANTLR end "class"

	partial void EnterRule_feature_list();
	partial void LeaveRule_feature_list();

	// $ANTLR start "feature_list"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:2: feature_list : ( feature )+ ;
	[GrammarRule("feature_list")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> feature_list()
	{
		EnterRule_feature_list();
		EnterRule("feature_list", 3);
		TraceIn("feature_list", 3);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		AstParserRuleReturnScope<COOLCommonTree, IToken> feature11 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "feature_list");
		DebugLocation(47, 23);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:14: ( ( feature )+ )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:16: ( feature )+
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(47, 16);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:16: ( feature )+
			int cnt4=0;
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==ID))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:16: feature
					{
					DebugLocation(47, 16);
					PushFollow(Follow._feature_in_feature_list153);
					feature11=feature();
					PopFollow();

					adaptor.AddChild(root_0, feature11.Tree);

					}
					break;

				default:
					if (cnt4 >= 1)
						goto loop4;

					EarlyExitException eee4 = new EarlyExitException( 4, input );
					DebugRecognitionException(eee4);
					throw eee4;
				}
				cnt4++;
			}
			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("feature_list", 3);
			LeaveRule("feature_list", 3);
			LeaveRule_feature_list();
		}
		DebugLocation(47, 23);
		} finally { DebugExitRule(GrammarFileName, "feature_list"); }
		return retval;

	}
	// $ANTLR end "feature_list"

	partial void EnterRule_feature();
	partial void LeaveRule_feature();

	// $ANTLR start "feature"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:2: feature : ( ID ( attribute -> ^( ATTRIBUTE ID attribute ) | methodefinition -> ^( METHOD ID methodefinition ) ) END ) ;
	[GrammarRule("feature")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> feature()
	{
		EnterRule_feature();
		EnterRule("feature", 4);
		TraceIn("feature", 4);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken ID12 = default(IToken);
		IToken END15 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> attribute13 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> methodefinition14 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree ID12_tree = default(COOLCommonTree);
		COOLCommonTree END15_tree = default(COOLCommonTree);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_attribute=new RewriteRuleSubtreeStream(adaptor,"rule attribute");
		RewriteRuleSubtreeStream stream_methodefinition=new RewriteRuleSubtreeStream(adaptor,"rule methodefinition");
		try { DebugEnterRule(GrammarFileName, "feature");
		DebugLocation(48, 106);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:9: ( ( ID ( attribute -> ^( ATTRIBUTE ID attribute ) | methodefinition -> ^( METHOD ID methodefinition ) ) END ) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:11: ( ID ( attribute -> ^( ATTRIBUTE ID attribute ) | methodefinition -> ^( METHOD ID methodefinition ) ) END )
			{
			DebugLocation(48, 11);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:11: ( ID ( attribute -> ^( ATTRIBUTE ID attribute ) | methodefinition -> ^( METHOD ID methodefinition ) ) END )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:12: ID ( attribute -> ^( ATTRIBUTE ID attribute ) | methodefinition -> ^( METHOD ID methodefinition ) ) END
			{
			DebugLocation(48, 12);
			ID12=(IToken)Match(input,ID,Follow._ID_in_feature162);  
			stream_ID.Add(ID12);

			DebugLocation(48, 15);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:15: ( attribute -> ^( ATTRIBUTE ID attribute ) | methodefinition -> ^( METHOD ID methodefinition ) )
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==DOUBLEP))
			{
				alt5 = 1;
			}
			else if ((LA5_0==OP_PARENT))
			{
				alt5 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:16: attribute
				{
				DebugLocation(48, 16);
				PushFollow(Follow._attribute_in_feature165);
				attribute13=attribute();
				PopFollow();

				stream_attribute.Add(attribute13.Tree);


				{
				// AST REWRITE
				// elements: ID, attribute
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (COOLCommonTree)adaptor.Nil();
				// 48:25: -> ^( ATTRIBUTE ID attribute )
				{
					DebugLocation(48, 28);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:28: ^( ATTRIBUTE ID attribute )
					{
					COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
					DebugLocation(48, 30);
					root_1 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(ATTRIBUTE, "ATTRIBUTE"), root_1);

					DebugLocation(48, 40);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(48, 43);
					adaptor.AddChild(root_1, stream_attribute.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:54: methodefinition
				{
				DebugLocation(48, 54);
				PushFollow(Follow._methodefinition_in_feature176);
				methodefinition14=methodefinition();
				PopFollow();

				stream_methodefinition.Add(methodefinition14.Tree);


				{
				// AST REWRITE
				// elements: methodefinition, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (COOLCommonTree)adaptor.Nil();
				// 48:69: -> ^( METHOD ID methodefinition )
				{
					DebugLocation(48, 72);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:72: ^( METHOD ID methodefinition )
					{
					COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
					DebugLocation(48, 74);
					root_1 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(METHOD, "METHOD"), root_1);

					DebugLocation(48, 81);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(48, 84);
					adaptor.AddChild(root_1, stream_methodefinition.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(48, 102);
			END15=(IToken)Match(input,END,Follow._END_in_feature188);  
			stream_END.Add(END15);


			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("feature", 4);
			LeaveRule("feature", 4);
			LeaveRule_feature();
		}
		DebugLocation(48, 106);
		} finally { DebugExitRule(GrammarFileName, "feature"); }
		return retval;

	}
	// $ANTLR end "feature"

	partial void EnterRule_attribute();
	partial void LeaveRule_attribute();

	// $ANTLR start "attribute"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:50:1: attribute : DOUBLEP ! TYPE ( ASSING expr )? ;
	[GrammarRule("attribute")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> attribute()
	{
		EnterRule_attribute();
		EnterRule("attribute", 5);
		TraceIn("attribute", 5);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken DOUBLEP16 = default(IToken);
		IToken TYPE17 = default(IToken);
		IToken ASSING18 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr19 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree DOUBLEP16_tree = default(COOLCommonTree);
		COOLCommonTree TYPE17_tree = default(COOLCommonTree);
		COOLCommonTree ASSING18_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "attribute");
		DebugLocation(50, 42);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:50:10: ( DOUBLEP ! TYPE ( ASSING expr )? )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:50:13: DOUBLEP ! TYPE ( ASSING expr )?
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(50, 20);
			DOUBLEP16=(IToken)Match(input,DOUBLEP,Follow._DOUBLEP_in_attribute199); 
			DebugLocation(50, 22);
			TYPE17=(IToken)Match(input,TYPE,Follow._TYPE_in_attribute202); 
			TYPE17_tree = (COOLCommonTree)adaptor.Create(TYPE17);
			adaptor.AddChild(root_0, TYPE17_tree);
			DebugLocation(50, 27);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:50:27: ( ASSING expr )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0==ASSING))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:50:28: ASSING expr
				{
				DebugLocation(50, 28);
				ASSING18=(IToken)Match(input,ASSING,Follow._ASSING_in_attribute205); 
				ASSING18_tree = (COOLCommonTree)adaptor.Create(ASSING18);
				adaptor.AddChild(root_0, ASSING18_tree);
				DebugLocation(50, 35);
				PushFollow(Follow._expr_in_attribute207);
				expr19=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr19.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("attribute", 5);
			LeaveRule("attribute", 5);
			LeaveRule_attribute();
		}
		DebugLocation(50, 42);
		} finally { DebugExitRule(GrammarFileName, "attribute"); }
		return retval;

	}
	// $ANTLR end "attribute"

	partial void EnterRule_methodefinition();
	partial void LeaveRule_methodefinition();

	// $ANTLR start "methodefinition"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:51:2: methodefinition : OP_PARENT ( params_list )? CL_PARENT DOUBLEP TYPE OP_LLAVE expr CL_LLAVE -> ^( METHODEFINITION ( params_list )? TYPE ^( BODY expr ) ) ;
	[GrammarRule("methodefinition")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> methodefinition()
	{
		EnterRule_methodefinition();
		EnterRule("methodefinition", 6);
		TraceIn("methodefinition", 6);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken OP_PARENT20 = default(IToken);
		IToken CL_PARENT22 = default(IToken);
		IToken DOUBLEP23 = default(IToken);
		IToken TYPE24 = default(IToken);
		IToken OP_LLAVE25 = default(IToken);
		IToken CL_LLAVE27 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> params_list21 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr26 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree OP_PARENT20_tree = default(COOLCommonTree);
		COOLCommonTree CL_PARENT22_tree = default(COOLCommonTree);
		COOLCommonTree DOUBLEP23_tree = default(COOLCommonTree);
		COOLCommonTree TYPE24_tree = default(COOLCommonTree);
		COOLCommonTree OP_LLAVE25_tree = default(COOLCommonTree);
		COOLCommonTree CL_LLAVE27_tree = default(COOLCommonTree);
		RewriteRuleITokenStream stream_CL_PARENT=new RewriteRuleITokenStream(adaptor,"token CL_PARENT");
		RewriteRuleITokenStream stream_OP_PARENT=new RewriteRuleITokenStream(adaptor,"token OP_PARENT");
		RewriteRuleITokenStream stream_DOUBLEP=new RewriteRuleITokenStream(adaptor,"token DOUBLEP");
		RewriteRuleITokenStream stream_OP_LLAVE=new RewriteRuleITokenStream(adaptor,"token OP_LLAVE");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleITokenStream stream_CL_LLAVE=new RewriteRuleITokenStream(adaptor,"token CL_LLAVE");
		RewriteRuleSubtreeStream stream_params_list=new RewriteRuleSubtreeStream(adaptor,"rule params_list");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "methodefinition");
		DebugLocation(51, 147);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:51:17: ( OP_PARENT ( params_list )? CL_PARENT DOUBLEP TYPE OP_LLAVE expr CL_LLAVE -> ^( METHODEFINITION ( params_list )? TYPE ^( BODY expr ) ) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:51:19: OP_PARENT ( params_list )? CL_PARENT DOUBLEP TYPE OP_LLAVE expr CL_LLAVE
			{
			DebugLocation(51, 19);
			OP_PARENT20=(IToken)Match(input,OP_PARENT,Follow._OP_PARENT_in_methodefinition218);  
			stream_OP_PARENT.Add(OP_PARENT20);

			DebugLocation(51, 29);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:51:29: ( params_list )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==ID))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:51:30: params_list
				{
				DebugLocation(51, 30);
				PushFollow(Follow._params_list_in_methodefinition221);
				params_list21=params_list();
				PopFollow();

				stream_params_list.Add(params_list21.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(51, 46);
			CL_PARENT22=(IToken)Match(input,CL_PARENT,Follow._CL_PARENT_in_methodefinition227);  
			stream_CL_PARENT.Add(CL_PARENT22);

			DebugLocation(51, 57);
			DOUBLEP23=(IToken)Match(input,DOUBLEP,Follow._DOUBLEP_in_methodefinition230);  
			stream_DOUBLEP.Add(DOUBLEP23);

			DebugLocation(51, 66);
			TYPE24=(IToken)Match(input,TYPE,Follow._TYPE_in_methodefinition233);  
			stream_TYPE.Add(TYPE24);

			DebugLocation(51, 72);
			OP_LLAVE25=(IToken)Match(input,OP_LLAVE,Follow._OP_LLAVE_in_methodefinition236);  
			stream_OP_LLAVE.Add(OP_LLAVE25);

			DebugLocation(51, 82);
			PushFollow(Follow._expr_in_methodefinition239);
			expr26=expr();
			PopFollow();

			stream_expr.Add(expr26.Tree);
			DebugLocation(51, 88);
			CL_LLAVE27=(IToken)Match(input,CL_LLAVE,Follow._CL_LLAVE_in_methodefinition242);  
			stream_CL_LLAVE.Add(CL_LLAVE27);



			{
			// AST REWRITE
			// elements: expr, params_list, TYPE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (COOLCommonTree)adaptor.Nil();
			// 51:96: -> ^( METHODEFINITION ( params_list )? TYPE ^( BODY expr ) )
			{
				DebugLocation(51, 98);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:51:98: ^( METHODEFINITION ( params_list )? TYPE ^( BODY expr ) )
				{
				COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
				DebugLocation(51, 100);
				root_1 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(METHODEFINITION, "METHODEFINITION"), root_1);

				DebugLocation(51, 116);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:51:116: ( params_list )?
				if (stream_params_list.HasNext)
				{
					DebugLocation(51, 116);
					adaptor.AddChild(root_1, stream_params_list.NextTree());

				}
				stream_params_list.Reset();
				DebugLocation(51, 129);
				adaptor.AddChild(root_1, stream_TYPE.NextNode());
				DebugLocation(51, 134);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:51:134: ^( BODY expr )
				{
				COOLCommonTree root_2 = (COOLCommonTree)adaptor.Nil();
				DebugLocation(51, 136);
				root_2 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(BODY, "BODY"), root_2);

				DebugLocation(51, 141);
				adaptor.AddChild(root_2, stream_expr.NextTree());

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("methodefinition", 6);
			LeaveRule("methodefinition", 6);
			LeaveRule_methodefinition();
		}
		DebugLocation(51, 147);
		} finally { DebugExitRule(GrammarFileName, "methodefinition"); }
		return retval;

	}
	// $ANTLR end "methodefinition"

	partial void EnterRule_params_list();
	partial void LeaveRule_params_list();

	// $ANTLR start "params_list"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:52:2: params_list : param ( COMA param )* -> ^( PARAMLIST param ( param )* ) ;
	[GrammarRule("params_list")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> params_list()
	{
		EnterRule_params_list();
		EnterRule("params_list", 7);
		TraceIn("params_list", 7);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken COMA29 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> param28 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> param30 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree COMA29_tree = default(COOLCommonTree);
		RewriteRuleITokenStream stream_COMA=new RewriteRuleITokenStream(adaptor,"token COMA");
		RewriteRuleSubtreeStream stream_param=new RewriteRuleSubtreeStream(adaptor,"rule param");
		try { DebugEnterRule(GrammarFileName, "params_list");
		DebugLocation(52, 61);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:52:13: ( param ( COMA param )* -> ^( PARAMLIST param ( param )* ) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:52:15: param ( COMA param )*
			{
			DebugLocation(52, 15);
			PushFollow(Follow._param_in_params_list265);
			param28=param();
			PopFollow();

			stream_param.Add(param28.Tree);
			DebugLocation(52, 21);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:52:21: ( COMA param )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==COMA))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:52:22: COMA param
					{
					DebugLocation(52, 22);
					COMA29=(IToken)Match(input,COMA,Follow._COMA_in_params_list268);  
					stream_COMA.Add(COMA29);

					DebugLocation(52, 28);
					PushFollow(Follow._param_in_params_list271);
					param30=param();
					PopFollow();

					stream_param.Add(param30.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }



			{
			// AST REWRITE
			// elements: param, param
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (COOLCommonTree)adaptor.Nil();
			// 52:35: -> ^( PARAMLIST param ( param )* )
			{
				DebugLocation(52, 37);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:52:37: ^( PARAMLIST param ( param )* )
				{
				COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
				DebugLocation(52, 39);
				root_1 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(PARAMLIST, "PARAMLIST"), root_1);

				DebugLocation(52, 49);
				adaptor.AddChild(root_1, stream_param.NextTree());
				DebugLocation(52, 55);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:52:55: ( param )*
				while ( stream_param.HasNext )
				{
					DebugLocation(52, 55);
					adaptor.AddChild(root_1, stream_param.NextTree());

				}
				stream_param.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("params_list", 7);
			LeaveRule("params_list", 7);
			LeaveRule_params_list();
		}
		DebugLocation(52, 61);
		} finally { DebugExitRule(GrammarFileName, "params_list"); }
		return retval;

	}
	// $ANTLR end "params_list"

	partial void EnterRule_param();
	partial void LeaveRule_param();

	// $ANTLR start "param"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:53:2: param : ( ID DOUBLEP TYPE ) -> ^( PARAM ID TYPE ) ;
	[GrammarRule("param")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> param()
	{
		EnterRule_param();
		EnterRule("param", 8);
		TraceIn("param", 8);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken ID31 = default(IToken);
		IToken DOUBLEP32 = default(IToken);
		IToken TYPE33 = default(IToken);

		COOLCommonTree ID31_tree = default(COOLCommonTree);
		COOLCommonTree DOUBLEP32_tree = default(COOLCommonTree);
		COOLCommonTree TYPE33_tree = default(COOLCommonTree);
		RewriteRuleITokenStream stream_DOUBLEP=new RewriteRuleITokenStream(adaptor,"token DOUBLEP");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		try { DebugEnterRule(GrammarFileName, "param");
		DebugLocation(53, 45);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:53:7: ( ( ID DOUBLEP TYPE ) -> ^( PARAM ID TYPE ) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:53:9: ( ID DOUBLEP TYPE )
			{
			DebugLocation(53, 9);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:53:9: ( ID DOUBLEP TYPE )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:53:10: ID DOUBLEP TYPE
			{
			DebugLocation(53, 10);
			ID31=(IToken)Match(input,ID,Follow._ID_in_param290);  
			stream_ID.Add(ID31);

			DebugLocation(53, 14);
			DOUBLEP32=(IToken)Match(input,DOUBLEP,Follow._DOUBLEP_in_param293);  
			stream_DOUBLEP.Add(DOUBLEP32);

			DebugLocation(53, 23);
			TYPE33=(IToken)Match(input,TYPE,Follow._TYPE_in_param296);  
			stream_TYPE.Add(TYPE33);


			}



			{
			// AST REWRITE
			// elements: TYPE, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (COOLCommonTree)adaptor.Nil();
			// 53:28: -> ^( PARAM ID TYPE )
			{
				DebugLocation(53, 30);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:53:30: ^( PARAM ID TYPE )
				{
				COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
				DebugLocation(53, 32);
				root_1 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(PARAM, "PARAM"), root_1);

				DebugLocation(53, 38);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(53, 41);
				adaptor.AddChild(root_1, stream_TYPE.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("param", 8);
			LeaveRule("param", 8);
			LeaveRule_param();
		}
		DebugLocation(53, 45);
		} finally { DebugExitRule(GrammarFileName, "param"); }
		return retval;

	}
	// $ANTLR end "param"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:55:2: expr : ( assignment | blocks | let | case | new | operations | TYPE ^| ( NOT ^ expr ) | ( ISVOID ^ expr ) );
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 9);
		TraceIn("expr", 9);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken TYPE40 = default(IToken);
		IToken NOT41 = default(IToken);
		IToken ISVOID43 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> assignment34 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> blocks35 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> let36 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> case37 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> new38 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> operations39 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr42 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr44 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree TYPE40_tree = default(COOLCommonTree);
		COOLCommonTree NOT41_tree = default(COOLCommonTree);
		COOLCommonTree ISVOID43_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(55, 20);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:55:6: ( assignment | blocks | let | case | new | operations | TYPE ^| ( NOT ^ expr ) | ( ISVOID ^ expr ) )
			int alt9=9;
			try { DebugEnterDecision(9, false);
			switch (input.LA(1))
			{
			case ID:
				{
				int LA9_1 = input.LA(2);

				if ((LA9_1==ASSING))
				{
					alt9 = 1;
				}
				else if ((LA9_1==EOF||LA9_1==ARROBA||(LA9_1>=CL_LLAVE && LA9_1<=COMA)||LA9_1==DIV||(LA9_1>=ELSE && LA9_1<=EQ)||(LA9_1>=FI && LA9_1<=GEQ)||LA9_1==IN||(LA9_1>=L && LA9_1<=LEQ)||LA9_1==LOOP||(LA9_1>=MINUS && LA9_1<=MULT)||LA9_1==OF||LA9_1==OP_PARENT||(LA9_1>=PLUS && LA9_1<=POOL)||LA9_1==THEN))
				{
					alt9 = 6;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 9, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case OP_LLAVE:
				{
				alt9 = 2;
				}
				break;
			case LET:
				{
				alt9 = 3;
				}
				break;
			case CASE:
				{
				alt9 = 4;
				}
				break;
			case NEW:
				{
				alt9 = 5;
				}
				break;
			case BOOLEAN:
			case IF:
			case NANARITA:
			case NUMBER:
			case OP_PARENT:
			case STRING:
			case WHILE:
				{
				alt9 = 6;
				}
				break;
			case TYPE:
				{
				alt9 = 7;
				}
				break;
			case NOT:
				{
				alt9 = 8;
				}
				break;
			case ISVOID:
				{
				alt9 = 9;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:55:8: assignment
				{
				root_0 = (COOLCommonTree)adaptor.Nil();

				DebugLocation(55, 8);
				PushFollow(Follow._assignment_in_expr313);
				assignment34=assignment();
				PopFollow();

				adaptor.AddChild(root_0, assignment34.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:57:6: blocks
				{
				root_0 = (COOLCommonTree)adaptor.Nil();

				DebugLocation(57, 6);
				PushFollow(Follow._blocks_in_expr325);
				blocks35=blocks();
				PopFollow();

				adaptor.AddChild(root_0, blocks35.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:58:6: let
				{
				root_0 = (COOLCommonTree)adaptor.Nil();

				DebugLocation(58, 6);
				PushFollow(Follow._let_in_expr332);
				let36=let();
				PopFollow();

				adaptor.AddChild(root_0, let36.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:59:6: case
				{
				root_0 = (COOLCommonTree)adaptor.Nil();

				DebugLocation(59, 6);
				PushFollow(Follow._case_in_expr339);
				case37=@case();
				PopFollow();

				adaptor.AddChild(root_0, case37.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:60:6: new
				{
				root_0 = (COOLCommonTree)adaptor.Nil();

				DebugLocation(60, 6);
				PushFollow(Follow._new_in_expr346);
				new38=@new();
				PopFollow();

				adaptor.AddChild(root_0, new38.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:61:6: operations
				{
				root_0 = (COOLCommonTree)adaptor.Nil();

				DebugLocation(61, 6);
				PushFollow(Follow._operations_in_expr353);
				operations39=operations();
				PopFollow();

				adaptor.AddChild(root_0, operations39.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:62:6: TYPE ^
				{
				root_0 = (COOLCommonTree)adaptor.Nil();

				DebugLocation(62, 10);
				TYPE40=(IToken)Match(input,TYPE,Follow._TYPE_in_expr360); 
				TYPE40_tree = (COOLCommonTree)adaptor.Create(TYPE40);
				root_0 = (COOLCommonTree)adaptor.BecomeRoot(TYPE40_tree, root_0);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:63:6: ( NOT ^ expr )
				{
				root_0 = (COOLCommonTree)adaptor.Nil();

				DebugLocation(63, 6);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:63:6: ( NOT ^ expr )
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:63:7: NOT ^ expr
				{
				DebugLocation(63, 10);
				NOT41=(IToken)Match(input,NOT,Follow._NOT_in_expr369); 
				NOT41_tree = (COOLCommonTree)adaptor.Create(NOT41);
				root_0 = (COOLCommonTree)adaptor.BecomeRoot(NOT41_tree, root_0);
				DebugLocation(63, 12);
				PushFollow(Follow._expr_in_expr372);
				expr42=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr42.Tree);

				}


				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:64:6: ( ISVOID ^ expr )
				{
				root_0 = (COOLCommonTree)adaptor.Nil();

				DebugLocation(64, 6);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:64:6: ( ISVOID ^ expr )
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:64:7: ISVOID ^ expr
				{
				DebugLocation(64, 13);
				ISVOID43=(IToken)Match(input,ISVOID,Follow._ISVOID_in_expr381); 
				ISVOID43_tree = (COOLCommonTree)adaptor.Create(ISVOID43);
				root_0 = (COOLCommonTree)adaptor.BecomeRoot(ISVOID43_tree, root_0);
				DebugLocation(64, 16);
				PushFollow(Follow._expr_in_expr385);
				expr44=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr44.Tree);

				}


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 9);
			LeaveRule("expr", 9);
			LeaveRule_expr();
		}
		DebugLocation(64, 20);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_exprList();
	partial void LeaveRule_exprList();

	// $ANTLR start "exprList"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:67:1: exprList : expr END ! ( expr END !)* ;
	[GrammarRule("exprList")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> exprList()
	{
		EnterRule_exprList();
		EnterRule("exprList", 10);
		TraceIn("exprList", 10);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken END46 = default(IToken);
		IToken END48 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr45 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr47 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree END46_tree = default(COOLCommonTree);
		COOLCommonTree END48_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "exprList");
		DebugLocation(67, 32);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:67:9: ( expr END ! ( expr END !)* )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:67:11: expr END ! ( expr END !)*
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(67, 11);
			PushFollow(Follow._expr_in_exprList396);
			expr45=expr();
			PopFollow();

			adaptor.AddChild(root_0, expr45.Tree);
			DebugLocation(67, 19);
			END46=(IToken)Match(input,END,Follow._END_in_exprList398); 
			DebugLocation(67, 21);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:67:21: ( expr END !)*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if (((LA10_0>=BOOLEAN && LA10_0<=CASE)||(LA10_0>=ID && LA10_0<=IF)||LA10_0==ISVOID||LA10_0==LET||(LA10_0>=NANARITA && LA10_0<=NEW)||(LA10_0>=NOT && LA10_0<=NUMBER)||(LA10_0>=OP_LLAVE && LA10_0<=OP_PARENT)||LA10_0==STRING||LA10_0==TYPE||LA10_0==WHILE))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:67:22: expr END !
					{
					DebugLocation(67, 22);
					PushFollow(Follow._expr_in_exprList402);
					expr47=expr();
					PopFollow();

					adaptor.AddChild(root_0, expr47.Tree);
					DebugLocation(67, 30);
					END48=(IToken)Match(input,END,Follow._END_in_exprList404); 

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exprList", 10);
			LeaveRule("exprList", 10);
			LeaveRule_exprList();
		}
		DebugLocation(67, 32);
		} finally { DebugExitRule(GrammarFileName, "exprList"); }
		return retval;

	}
	// $ANTLR end "exprList"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();

	// $ANTLR start "assignment"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:68:2: assignment : ( ID ASSING ^ expr ) ;
	[GrammarRule("assignment")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 11);
		TraceIn("assignment", 11);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken ID49 = default(IToken);
		IToken ASSING50 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr51 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree ID49_tree = default(COOLCommonTree);
		COOLCommonTree ASSING50_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(68, 32);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:68:12: ( ( ID ASSING ^ expr ) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:68:14: ( ID ASSING ^ expr )
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(68, 14);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:68:14: ( ID ASSING ^ expr )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:68:15: ID ASSING ^ expr
			{
			DebugLocation(68, 15);
			ID49=(IToken)Match(input,ID,Follow._ID_in_assignment415); 
			ID49_tree = (COOLCommonTree)adaptor.Create(ID49);
			adaptor.AddChild(root_0, ID49_tree);
			DebugLocation(68, 24);
			ASSING50=(IToken)Match(input,ASSING,Follow._ASSING_in_assignment417); 
			ASSING50_tree = (COOLCommonTree)adaptor.Create(ASSING50);
			root_0 = (COOLCommonTree)adaptor.BecomeRoot(ASSING50_tree, root_0);
			DebugLocation(68, 27);
			PushFollow(Follow._expr_in_assignment421);
			expr51=expr();
			PopFollow();

			adaptor.AddChild(root_0, expr51.Tree);

			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignment", 11);
			LeaveRule("assignment", 11);
			LeaveRule_assignment();
		}
		DebugLocation(68, 32);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return retval;

	}
	// $ANTLR end "assignment"

	partial void EnterRule_conditionals();
	partial void LeaveRule_conditionals();

	// $ANTLR start "conditionals"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:69:2: conditionals : ( IF expr ( THEN expr ) ( ELSE expr )? FI ) -> ^( IF expr ^( THEN expr ) ( ^( ELSE expr ) )? ) ;
	[GrammarRule("conditionals")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> conditionals()
	{
		EnterRule_conditionals();
		EnterRule("conditionals", 12);
		TraceIn("conditionals", 12);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken IF52 = default(IToken);
		IToken THEN54 = default(IToken);
		IToken ELSE56 = default(IToken);
		IToken FI58 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr53 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr55 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr57 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree IF52_tree = default(COOLCommonTree);
		COOLCommonTree THEN54_tree = default(COOLCommonTree);
		COOLCommonTree ELSE56_tree = default(COOLCommonTree);
		COOLCommonTree FI58_tree = default(COOLCommonTree);
		RewriteRuleITokenStream stream_THEN=new RewriteRuleITokenStream(adaptor,"token THEN");
		RewriteRuleITokenStream stream_IF=new RewriteRuleITokenStream(adaptor,"token IF");
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleITokenStream stream_FI=new RewriteRuleITokenStream(adaptor,"token FI");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "conditionals");
		DebugLocation(69, 92);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:69:14: ( ( IF expr ( THEN expr ) ( ELSE expr )? FI ) -> ^( IF expr ^( THEN expr ) ( ^( ELSE expr ) )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:69:16: ( IF expr ( THEN expr ) ( ELSE expr )? FI )
			{
			DebugLocation(69, 16);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:69:16: ( IF expr ( THEN expr ) ( ELSE expr )? FI )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:69:17: IF expr ( THEN expr ) ( ELSE expr )? FI
			{
			DebugLocation(69, 17);
			IF52=(IToken)Match(input,IF,Follow._IF_in_conditionals431);  
			stream_IF.Add(IF52);

			DebugLocation(69, 20);
			PushFollow(Follow._expr_in_conditionals433);
			expr53=expr();
			PopFollow();

			stream_expr.Add(expr53.Tree);
			DebugLocation(69, 25);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:69:25: ( THEN expr )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:69:26: THEN expr
			{
			DebugLocation(69, 26);
			THEN54=(IToken)Match(input,THEN,Follow._THEN_in_conditionals436);  
			stream_THEN.Add(THEN54);

			DebugLocation(69, 31);
			PushFollow(Follow._expr_in_conditionals438);
			expr55=expr();
			PopFollow();

			stream_expr.Add(expr55.Tree);

			}

			DebugLocation(69, 37);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:69:37: ( ELSE expr )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==ELSE))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:69:38: ELSE expr
				{
				DebugLocation(69, 38);
				ELSE56=(IToken)Match(input,ELSE,Follow._ELSE_in_conditionals442);  
				stream_ELSE.Add(ELSE56);

				DebugLocation(69, 43);
				PushFollow(Follow._expr_in_conditionals444);
				expr57=expr();
				PopFollow();

				stream_expr.Add(expr57.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(69, 50);
			FI58=(IToken)Match(input,FI,Follow._FI_in_conditionals448);  
			stream_FI.Add(FI58);


			}



			{
			// AST REWRITE
			// elements: IF, expr, expr, ELSE, expr, THEN
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (COOLCommonTree)adaptor.Nil();
			// 69:53: -> ^( IF expr ^( THEN expr ) ( ^( ELSE expr ) )? )
			{
				DebugLocation(69, 55);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:69:55: ^( IF expr ^( THEN expr ) ( ^( ELSE expr ) )? )
				{
				COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
				DebugLocation(69, 57);
				root_1 = (COOLCommonTree)adaptor.BecomeRoot(stream_IF.NextNode(), root_1);

				DebugLocation(69, 60);
				adaptor.AddChild(root_1, stream_expr.NextTree());
				DebugLocation(69, 65);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:69:65: ^( THEN expr )
				{
				COOLCommonTree root_2 = (COOLCommonTree)adaptor.Nil();
				DebugLocation(69, 67);
				root_2 = (COOLCommonTree)adaptor.BecomeRoot(stream_THEN.NextNode(), root_2);

				DebugLocation(69, 72);
				adaptor.AddChild(root_2, stream_expr.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(69, 78);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:69:78: ( ^( ELSE expr ) )?
				if (stream_expr.HasNext||stream_ELSE.HasNext)
				{
					DebugLocation(69, 78);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:69:78: ^( ELSE expr )
					{
					COOLCommonTree root_2 = (COOLCommonTree)adaptor.Nil();
					DebugLocation(69, 80);
					root_2 = (COOLCommonTree)adaptor.BecomeRoot(stream_ELSE.NextNode(), root_2);

					DebugLocation(69, 85);
					adaptor.AddChild(root_2, stream_expr.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

				}
				stream_expr.Reset();
				stream_ELSE.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionals", 12);
			LeaveRule("conditionals", 12);
			LeaveRule_conditionals();
		}
		DebugLocation(69, 92);
		} finally { DebugExitRule(GrammarFileName, "conditionals"); }
		return retval;

	}
	// $ANTLR end "conditionals"

	partial void EnterRule_loops();
	partial void LeaveRule_loops();

	// $ANTLR start "loops"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:70:2: loops : WHILE ^ expr LOOP ! expr POOL !;
	[GrammarRule("loops")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> loops()
	{
		EnterRule_loops();
		EnterRule("loops", 13);
		TraceIn("loops", 13);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken WHILE59 = default(IToken);
		IToken LOOP61 = default(IToken);
		IToken POOL63 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr60 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr62 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree WHILE59_tree = default(COOLCommonTree);
		COOLCommonTree LOOP61_tree = default(COOLCommonTree);
		COOLCommonTree POOL63_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "loops");
		DebugLocation(70, 38);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:70:7: ( WHILE ^ expr LOOP ! expr POOL !)
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:70:9: WHILE ^ expr LOOP ! expr POOL !
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(70, 14);
			WHILE59=(IToken)Match(input,WHILE,Follow._WHILE_in_loops476); 
			WHILE59_tree = (COOLCommonTree)adaptor.Create(WHILE59);
			root_0 = (COOLCommonTree)adaptor.BecomeRoot(WHILE59_tree, root_0);
			DebugLocation(70, 17);
			PushFollow(Follow._expr_in_loops480);
			expr60=expr();
			PopFollow();

			adaptor.AddChild(root_0, expr60.Tree);
			DebugLocation(70, 26);
			LOOP61=(IToken)Match(input,LOOP,Follow._LOOP_in_loops482); 
			DebugLocation(70, 28);
			PushFollow(Follow._expr_in_loops485);
			expr62=expr();
			PopFollow();

			adaptor.AddChild(root_0, expr62.Tree);
			DebugLocation(70, 37);
			POOL63=(IToken)Match(input,POOL,Follow._POOL_in_loops487); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("loops", 13);
			LeaveRule("loops", 13);
			LeaveRule_loops();
		}
		DebugLocation(70, 38);
		} finally { DebugExitRule(GrammarFileName, "loops"); }
		return retval;

	}
	// $ANTLR end "loops"

	partial void EnterRule_blocks();
	partial void LeaveRule_blocks();

	// $ANTLR start "blocks"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:71:2: blocks : OP_LLAVE exprList CL_LLAVE -> ^( BLOCK exprList ) ;
	[GrammarRule("blocks")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> blocks()
	{
		EnterRule_blocks();
		EnterRule("blocks", 14);
		TraceIn("blocks", 14);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken OP_LLAVE64 = default(IToken);
		IToken CL_LLAVE66 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> exprList65 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree OP_LLAVE64_tree = default(COOLCommonTree);
		COOLCommonTree CL_LLAVE66_tree = default(COOLCommonTree);
		RewriteRuleITokenStream stream_OP_LLAVE=new RewriteRuleITokenStream(adaptor,"token OP_LLAVE");
		RewriteRuleITokenStream stream_CL_LLAVE=new RewriteRuleITokenStream(adaptor,"token CL_LLAVE");
		RewriteRuleSubtreeStream stream_exprList=new RewriteRuleSubtreeStream(adaptor,"rule exprList");
		try { DebugEnterRule(GrammarFileName, "blocks");
		DebugLocation(71, 56);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:71:8: ( OP_LLAVE exprList CL_LLAVE -> ^( BLOCK exprList ) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:71:10: OP_LLAVE exprList CL_LLAVE
			{
			DebugLocation(71, 10);
			OP_LLAVE64=(IToken)Match(input,OP_LLAVE,Follow._OP_LLAVE_in_blocks496);  
			stream_OP_LLAVE.Add(OP_LLAVE64);

			DebugLocation(71, 20);
			PushFollow(Follow._exprList_in_blocks499);
			exprList65=exprList();
			PopFollow();

			stream_exprList.Add(exprList65.Tree);
			DebugLocation(71, 29);
			CL_LLAVE66=(IToken)Match(input,CL_LLAVE,Follow._CL_LLAVE_in_blocks501);  
			stream_CL_LLAVE.Add(CL_LLAVE66);



			{
			// AST REWRITE
			// elements: exprList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (COOLCommonTree)adaptor.Nil();
			// 71:37: -> ^( BLOCK exprList )
			{
				DebugLocation(71, 39);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:71:39: ^( BLOCK exprList )
				{
				COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
				DebugLocation(71, 41);
				root_1 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(BLOCK, "BLOCK"), root_1);

				DebugLocation(71, 47);
				adaptor.AddChild(root_1, stream_exprList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("blocks", 14);
			LeaveRule("blocks", 14);
			LeaveRule_blocks();
		}
		DebugLocation(71, 56);
		} finally { DebugExitRule(GrammarFileName, "blocks"); }
		return retval;

	}
	// $ANTLR end "blocks"

	partial void EnterRule_let();
	partial void LeaveRule_let();

	// $ANTLR start "let"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:72:2: let : ( LET var_list_declaration IN expr ) -> ^( LET var_list_declaration ^( BODY expr ) ) ;
	[GrammarRule("let")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> let()
	{
		EnterRule_let();
		EnterRule("let", 15);
		TraceIn("let", 15);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken LET67 = default(IToken);
		IToken IN69 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> var_list_declaration68 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr70 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree LET67_tree = default(COOLCommonTree);
		COOLCommonTree IN69_tree = default(COOLCommonTree);
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_LET=new RewriteRuleITokenStream(adaptor,"token LET");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_var_list_declaration=new RewriteRuleSubtreeStream(adaptor,"rule var_list_declaration");
		try { DebugEnterRule(GrammarFileName, "let");
		DebugLocation(72, 84);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:72:5: ( ( LET var_list_declaration IN expr ) -> ^( LET var_list_declaration ^( BODY expr ) ) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:72:7: ( LET var_list_declaration IN expr )
			{
			DebugLocation(72, 7);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:72:7: ( LET var_list_declaration IN expr )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:72:8: LET var_list_declaration IN expr
			{
			DebugLocation(72, 8);
			LET67=(IToken)Match(input,LET,Follow._LET_in_let516);  
			stream_LET.Add(LET67);

			DebugLocation(72, 13);
			PushFollow(Follow._var_list_declaration_in_let519);
			var_list_declaration68=var_list_declaration();
			PopFollow();

			stream_var_list_declaration.Add(var_list_declaration68.Tree);
			DebugLocation(72, 34);
			IN69=(IToken)Match(input,IN,Follow._IN_in_let521);  
			stream_IN.Add(IN69);

			DebugLocation(72, 37);
			PushFollow(Follow._expr_in_let523);
			expr70=expr();
			PopFollow();

			stream_expr.Add(expr70.Tree);

			}



			{
			// AST REWRITE
			// elements: LET, expr, var_list_declaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (COOLCommonTree)adaptor.Nil();
			// 72:42: -> ^( LET var_list_declaration ^( BODY expr ) )
			{
				DebugLocation(72, 44);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:72:44: ^( LET var_list_declaration ^( BODY expr ) )
				{
				COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
				DebugLocation(72, 46);
				root_1 = (COOLCommonTree)adaptor.BecomeRoot(stream_LET.NextNode(), root_1);

				DebugLocation(72, 50);
				adaptor.AddChild(root_1, stream_var_list_declaration.NextTree());
				DebugLocation(72, 71);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:72:71: ^( BODY expr )
				{
				COOLCommonTree root_2 = (COOLCommonTree)adaptor.Nil();
				DebugLocation(72, 73);
				root_2 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(BODY, "BODY"), root_2);

				DebugLocation(72, 78);
				adaptor.AddChild(root_2, stream_expr.NextTree());

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("let", 15);
			LeaveRule("let", 15);
			LeaveRule_let();
		}
		DebugLocation(72, 84);
		} finally { DebugExitRule(GrammarFileName, "let"); }
		return retval;

	}
	// $ANTLR end "let"

	partial void EnterRule_vardeclaration();
	partial void LeaveRule_vardeclaration();

	// $ANTLR start "vardeclaration"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:73:2: vardeclaration : ID attribute -> ^( VAR_DECLARATION ID attribute ) ;
	[GrammarRule("vardeclaration")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> vardeclaration()
	{
		EnterRule_vardeclaration();
		EnterRule("vardeclaration", 16);
		TraceIn("vardeclaration", 16);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken ID71 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> attribute72 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree ID71_tree = default(COOLCommonTree);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_attribute=new RewriteRuleSubtreeStream(adaptor,"rule attribute");
		try { DebugEnterRule(GrammarFileName, "vardeclaration");
		DebugLocation(73, 50);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:74:3: ( ID attribute -> ^( VAR_DECLARATION ID attribute ) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:74:5: ID attribute
			{
			DebugLocation(74, 5);
			ID71=(IToken)Match(input,ID,Follow._ID_in_vardeclaration547);  
			stream_ID.Add(ID71);

			DebugLocation(74, 8);
			PushFollow(Follow._attribute_in_vardeclaration549);
			attribute72=attribute();
			PopFollow();

			stream_attribute.Add(attribute72.Tree);


			{
			// AST REWRITE
			// elements: ID, attribute
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (COOLCommonTree)adaptor.Nil();
			// 74:17: -> ^( VAR_DECLARATION ID attribute )
			{
				DebugLocation(74, 19);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:74:19: ^( VAR_DECLARATION ID attribute )
				{
				COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
				DebugLocation(74, 21);
				root_1 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(VAR_DECLARATION, "VAR_DECLARATION"), root_1);

				DebugLocation(74, 37);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(74, 41);
				adaptor.AddChild(root_1, stream_attribute.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("vardeclaration", 16);
			LeaveRule("vardeclaration", 16);
			LeaveRule_vardeclaration();
		}
		DebugLocation(74, 50);
		} finally { DebugExitRule(GrammarFileName, "vardeclaration"); }
		return retval;

	}
	// $ANTLR end "vardeclaration"

	partial void EnterRule_var_list_declaration();
	partial void LeaveRule_var_list_declaration();

	// $ANTLR start "var_list_declaration"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:75:2: var_list_declaration : ( vardeclaration -> vardeclaration ) ( COMA vardeclaration )* -> ^( VAR_DECLARATION_LIST $var_list_declaration ( vardeclaration )* ) ;
	[GrammarRule("var_list_declaration")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> var_list_declaration()
	{
		EnterRule_var_list_declaration();
		EnterRule("var_list_declaration", 17);
		TraceIn("var_list_declaration", 17);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken COMA74 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> vardeclaration73 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> vardeclaration75 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree COMA74_tree = default(COOLCommonTree);
		RewriteRuleITokenStream stream_COMA=new RewriteRuleITokenStream(adaptor,"token COMA");
		RewriteRuleSubtreeStream stream_vardeclaration=new RewriteRuleSubtreeStream(adaptor,"rule vardeclaration");
		try { DebugEnterRule(GrammarFileName, "var_list_declaration");
		DebugLocation(75, 124);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:76:3: ( ( vardeclaration -> vardeclaration ) ( COMA vardeclaration )* -> ^( VAR_DECLARATION_LIST $var_list_declaration ( vardeclaration )* ) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:76:6: ( vardeclaration -> vardeclaration ) ( COMA vardeclaration )*
			{
			DebugLocation(76, 6);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:76:6: ( vardeclaration -> vardeclaration )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:76:7: vardeclaration
			{
			DebugLocation(76, 7);
			PushFollow(Follow._vardeclaration_in_var_list_declaration570);
			vardeclaration73=vardeclaration();
			PopFollow();

			stream_vardeclaration.Add(vardeclaration73.Tree);


			{
			// AST REWRITE
			// elements: vardeclaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (COOLCommonTree)adaptor.Nil();
			// 76:21: -> vardeclaration
			{
				DebugLocation(76, 24);
				adaptor.AddChild(root_0, stream_vardeclaration.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(76, 40);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:76:40: ( COMA vardeclaration )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==COMA))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:76:41: COMA vardeclaration
					{
					DebugLocation(76, 41);
					COMA74=(IToken)Match(input,COMA,Follow._COMA_in_var_list_declaration577);  
					stream_COMA.Add(COMA74);

					DebugLocation(76, 46);
					PushFollow(Follow._vardeclaration_in_var_list_declaration579);
					vardeclaration75=vardeclaration();
					PopFollow();

					stream_vardeclaration.Add(vardeclaration75.Tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }



			{
			// AST REWRITE
			// elements: var_list_declaration, vardeclaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (COOLCommonTree)adaptor.Nil();
			// 76:62: -> ^( VAR_DECLARATION_LIST $var_list_declaration ( vardeclaration )* )
			{
				DebugLocation(76, 64);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:76:64: ^( VAR_DECLARATION_LIST $var_list_declaration ( vardeclaration )* )
				{
				COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
				DebugLocation(76, 66);
				root_1 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(VAR_DECLARATION_LIST, "VAR_DECLARATION_LIST"), root_1);

				DebugLocation(76, 88);
				adaptor.AddChild(root_1, stream_retval.NextTree());
				DebugLocation(76, 109);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:76:109: ( vardeclaration )*
				while ( stream_vardeclaration.HasNext )
				{
					DebugLocation(76, 109);
					adaptor.AddChild(root_1, stream_vardeclaration.NextTree());

				}
				stream_vardeclaration.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("var_list_declaration", 17);
			LeaveRule("var_list_declaration", 17);
			LeaveRule_var_list_declaration();
		}
		DebugLocation(76, 124);
		} finally { DebugExitRule(GrammarFileName, "var_list_declaration"); }
		return retval;

	}
	// $ANTLR end "var_list_declaration"

	partial void EnterRule_case();
	partial void LeaveRule_case();

	// $ANTLR start "case"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:77:2: case : CASE ^ expr OF ! caseBranches ESAC !;
	[GrammarRule("case")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> @case()
	{
		EnterRule_case();
		EnterRule("case", 18);
		TraceIn("case", 18);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken CASE76 = default(IToken);
		IToken OF78 = default(IToken);
		IToken ESAC80 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr77 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> caseBranches79 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree CASE76_tree = default(COOLCommonTree);
		COOLCommonTree OF78_tree = default(COOLCommonTree);
		COOLCommonTree ESAC80_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "case");
		DebugLocation(77, 41);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:77:6: ( CASE ^ expr OF ! caseBranches ESAC !)
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:77:8: CASE ^ expr OF ! caseBranches ESAC !
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(77, 12);
			CASE76=(IToken)Match(input,CASE,Follow._CASE_in_case598); 
			CASE76_tree = (COOLCommonTree)adaptor.Create(CASE76);
			root_0 = (COOLCommonTree)adaptor.BecomeRoot(CASE76_tree, root_0);
			DebugLocation(77, 14);
			PushFollow(Follow._expr_in_case601);
			expr77=expr();
			PopFollow();

			adaptor.AddChild(root_0, expr77.Tree);
			DebugLocation(77, 21);
			OF78=(IToken)Match(input,OF,Follow._OF_in_case603); 
			DebugLocation(77, 23);
			PushFollow(Follow._caseBranches_in_case606);
			caseBranches79=caseBranches();
			PopFollow();

			adaptor.AddChild(root_0, caseBranches79.Tree);
			DebugLocation(77, 40);
			ESAC80=(IToken)Match(input,ESAC,Follow._ESAC_in_case608); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("case", 18);
			LeaveRule("case", 18);
			LeaveRule_case();
		}
		DebugLocation(77, 41);
		} finally { DebugExitRule(GrammarFileName, "case"); }
		return retval;

	}
	// $ANTLR end "case"

	partial void EnterRule_caseBranch();
	partial void LeaveRule_caseBranch();

	// $ANTLR start "caseBranch"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:78:2: caseBranch : param IMPLICS expr END -> ^( CASEBRANCH param expr ) ;
	[GrammarRule("caseBranch")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> caseBranch()
	{
		EnterRule_caseBranch();
		EnterRule("caseBranch", 19);
		TraceIn("caseBranch", 19);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken IMPLICS82 = default(IToken);
		IToken END84 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> param81 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr83 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree IMPLICS82_tree = default(COOLCommonTree);
		COOLCommonTree END84_tree = default(COOLCommonTree);
		RewriteRuleITokenStream stream_IMPLICS=new RewriteRuleITokenStream(adaptor,"token IMPLICS");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_param=new RewriteRuleSubtreeStream(adaptor,"rule param");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "caseBranch");
		DebugLocation(78, 53);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:79:3: ( param IMPLICS expr END -> ^( CASEBRANCH param expr ) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:79:5: param IMPLICS expr END
			{
			DebugLocation(79, 5);
			PushFollow(Follow._param_in_caseBranch620);
			param81=param();
			PopFollow();

			stream_param.Add(param81.Tree);
			DebugLocation(79, 11);
			IMPLICS82=(IToken)Match(input,IMPLICS,Follow._IMPLICS_in_caseBranch622);  
			stream_IMPLICS.Add(IMPLICS82);

			DebugLocation(79, 19);
			PushFollow(Follow._expr_in_caseBranch624);
			expr83=expr();
			PopFollow();

			stream_expr.Add(expr83.Tree);
			DebugLocation(79, 24);
			END84=(IToken)Match(input,END,Follow._END_in_caseBranch626);  
			stream_END.Add(END84);



			{
			// AST REWRITE
			// elements: expr, param
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (COOLCommonTree)adaptor.Nil();
			// 79:27: -> ^( CASEBRANCH param expr )
			{
				DebugLocation(79, 30);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:79:30: ^( CASEBRANCH param expr )
				{
				COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
				DebugLocation(79, 32);
				root_1 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(CASEBRANCH, "CASEBRANCH"), root_1);

				DebugLocation(79, 43);
				adaptor.AddChild(root_1, stream_param.NextTree());
				DebugLocation(79, 49);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseBranch", 19);
			LeaveRule("caseBranch", 19);
			LeaveRule_caseBranch();
		}
		DebugLocation(79, 53);
		} finally { DebugExitRule(GrammarFileName, "caseBranch"); }
		return retval;

	}
	// $ANTLR end "caseBranch"

	partial void EnterRule_caseBranches();
	partial void LeaveRule_caseBranches();

	// $ANTLR start "caseBranches"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:80:2: caseBranches : ( caseBranch -> caseBranch ) ( caseBranch )* -> ^( CASEBRANCHES $caseBranches ( caseBranch )* ) ;
	[GrammarRule("caseBranches")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> caseBranches()
	{
		EnterRule_caseBranches();
		EnterRule("caseBranches", 20);
		TraceIn("caseBranches", 20);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		AstParserRuleReturnScope<COOLCommonTree, IToken> caseBranch85 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> caseBranch86 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		RewriteRuleSubtreeStream stream_caseBranch=new RewriteRuleSubtreeStream(adaptor,"rule caseBranch");
		try { DebugEnterRule(GrammarFileName, "caseBranches");
		DebugLocation(80, 86);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:81:3: ( ( caseBranch -> caseBranch ) ( caseBranch )* -> ^( CASEBRANCHES $caseBranches ( caseBranch )* ) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:81:5: ( caseBranch -> caseBranch ) ( caseBranch )*
			{
			DebugLocation(81, 5);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:81:5: ( caseBranch -> caseBranch )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:81:6: caseBranch
			{
			DebugLocation(81, 6);
			PushFollow(Follow._caseBranch_in_caseBranches646);
			caseBranch85=caseBranch();
			PopFollow();

			stream_caseBranch.Add(caseBranch85.Tree);


			{
			// AST REWRITE
			// elements: caseBranch
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (COOLCommonTree)adaptor.Nil();
			// 81:16: -> caseBranch
			{
				DebugLocation(81, 18);
				adaptor.AddChild(root_0, stream_caseBranch.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(81, 30);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:81:30: ( caseBranch )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if ((LA13_0==ID))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:81:31: caseBranch
					{
					DebugLocation(81, 31);
					PushFollow(Follow._caseBranch_in_caseBranches652);
					caseBranch86=caseBranch();
					PopFollow();

					stream_caseBranch.Add(caseBranch86.Tree);

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }



			{
			// AST REWRITE
			// elements: caseBranch, caseBranches
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (COOLCommonTree)adaptor.Nil();
			// 81:43: -> ^( CASEBRANCHES $caseBranches ( caseBranch )* )
			{
				DebugLocation(81, 45);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:81:45: ^( CASEBRANCHES $caseBranches ( caseBranch )* )
				{
				COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
				DebugLocation(81, 48);
				root_1 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(CASEBRANCHES, "CASEBRANCHES"), root_1);

				DebugLocation(81, 62);
				adaptor.AddChild(root_1, stream_retval.NextTree());
				DebugLocation(81, 75);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:81:75: ( caseBranch )*
				while ( stream_caseBranch.HasNext )
				{
					DebugLocation(81, 75);
					adaptor.AddChild(root_1, stream_caseBranch.NextTree());

				}
				stream_caseBranch.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseBranches", 20);
			LeaveRule("caseBranches", 20);
			LeaveRule_caseBranches();
		}
		DebugLocation(81, 86);
		} finally { DebugExitRule(GrammarFileName, "caseBranches"); }
		return retval;

	}
	// $ANTLR end "caseBranches"

	partial void EnterRule_new();
	partial void LeaveRule_new();

	// $ANTLR start "new"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:82:2: new : ( NEW ^ TYPE ) ;
	[GrammarRule("new")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> @new()
	{
		EnterRule_new();
		EnterRule("new", 21);
		TraceIn("new", 21);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken NEW87 = default(IToken);
		IToken TYPE88 = default(IToken);

		COOLCommonTree NEW87_tree = default(COOLCommonTree);
		COOLCommonTree TYPE88_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "new");
		DebugLocation(82, 19);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:82:6: ( ( NEW ^ TYPE ) )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:82:8: ( NEW ^ TYPE )
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(82, 8);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:82:8: ( NEW ^ TYPE )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:82:9: NEW ^ TYPE
			{
			DebugLocation(82, 12);
			NEW87=(IToken)Match(input,NEW,Follow._NEW_in_new674); 
			NEW87_tree = (COOLCommonTree)adaptor.Create(NEW87);
			root_0 = (COOLCommonTree)adaptor.BecomeRoot(NEW87_tree, root_0);
			DebugLocation(82, 14);
			TYPE88=(IToken)Match(input,TYPE,Follow._TYPE_in_new677); 
			TYPE88_tree = (COOLCommonTree)adaptor.Create(TYPE88);
			adaptor.AddChild(root_0, TYPE88_tree);

			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("new", 21);
			LeaveRule("new", 21);
			LeaveRule_new();
		}
		DebugLocation(82, 19);
		} finally { DebugExitRule(GrammarFileName, "new"); }
		return retval;

	}
	// $ANTLR end "new"

	partial void EnterRule_dispatch();
	partial void LeaveRule_dispatch();

	// $ANTLR start "dispatch"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:84:2: dispatch : ( ARROBA ! TYPE PNT !| PNT !) ID OP_PARENT ( expr ( COMA ! expr )* )? CL_PARENT !;
	[GrammarRule("dispatch")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> dispatch()
	{
		EnterRule_dispatch();
		EnterRule("dispatch", 22);
		TraceIn("dispatch", 22);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken ARROBA89 = default(IToken);
		IToken TYPE90 = default(IToken);
		IToken PNT91 = default(IToken);
		IToken PNT92 = default(IToken);
		IToken ID93 = default(IToken);
		IToken OP_PARENT94 = default(IToken);
		IToken COMA96 = default(IToken);
		IToken CL_PARENT98 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr95 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr97 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree ARROBA89_tree = default(COOLCommonTree);
		COOLCommonTree TYPE90_tree = default(COOLCommonTree);
		COOLCommonTree PNT91_tree = default(COOLCommonTree);
		COOLCommonTree PNT92_tree = default(COOLCommonTree);
		COOLCommonTree ID93_tree = default(COOLCommonTree);
		COOLCommonTree OP_PARENT94_tree = default(COOLCommonTree);
		COOLCommonTree COMA96_tree = default(COOLCommonTree);
		COOLCommonTree CL_PARENT98_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "dispatch");
		DebugLocation(84, 83);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:84:10: ( ( ARROBA ! TYPE PNT !| PNT !) ID OP_PARENT ( expr ( COMA ! expr )* )? CL_PARENT !)
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:84:12: ( ARROBA ! TYPE PNT !| PNT !) ID OP_PARENT ( expr ( COMA ! expr )* )? CL_PARENT !
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(84, 12);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:84:12: ( ARROBA ! TYPE PNT !| PNT !)
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_0 = input.LA(1);

			if ((LA14_0==ARROBA))
			{
				alt14 = 1;
			}
			else if ((LA14_0==PNT))
			{
				alt14 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:84:13: ARROBA ! TYPE PNT !
				{
				DebugLocation(84, 19);
				ARROBA89=(IToken)Match(input,ARROBA,Follow._ARROBA_in_dispatch689); 
				DebugLocation(84, 21);
				TYPE90=(IToken)Match(input,TYPE,Follow._TYPE_in_dispatch692); 
				TYPE90_tree = (COOLCommonTree)adaptor.Create(TYPE90);
				adaptor.AddChild(root_0, TYPE90_tree);
				DebugLocation(84, 29);
				PNT91=(IToken)Match(input,PNT,Follow._PNT_in_dispatch694); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:84:31: PNT !
				{
				DebugLocation(84, 34);
				PNT92=(IToken)Match(input,PNT,Follow._PNT_in_dispatch697); 

				}
				break;

			}
			} finally { DebugExitSubRule(14); }

			DebugLocation(84, 37);
			ID93=(IToken)Match(input,ID,Follow._ID_in_dispatch701); 
			ID93_tree = (COOLCommonTree)adaptor.Create(ID93);
			adaptor.AddChild(root_0, ID93_tree);
			DebugLocation(84, 40);
			OP_PARENT94=(IToken)Match(input,OP_PARENT,Follow._OP_PARENT_in_dispatch703); 
			OP_PARENT94_tree = (COOLCommonTree)adaptor.Create(OP_PARENT94);
			adaptor.AddChild(root_0, OP_PARENT94_tree);
			DebugLocation(84, 50);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:84:50: ( expr ( COMA ! expr )* )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_0 = input.LA(1);

			if (((LA16_0>=BOOLEAN && LA16_0<=CASE)||(LA16_0>=ID && LA16_0<=IF)||LA16_0==ISVOID||LA16_0==LET||(LA16_0>=NANARITA && LA16_0<=NEW)||(LA16_0>=NOT && LA16_0<=NUMBER)||(LA16_0>=OP_LLAVE && LA16_0<=OP_PARENT)||LA16_0==STRING||LA16_0==TYPE||LA16_0==WHILE))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:84:51: expr ( COMA ! expr )*
				{
				DebugLocation(84, 51);
				PushFollow(Follow._expr_in_dispatch706);
				expr95=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr95.Tree);
				DebugLocation(84, 56);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:84:56: ( COMA ! expr )*
				try { DebugEnterSubRule(15);
				while (true)
				{
					int alt15=2;
					try { DebugEnterDecision(15, false);
					int LA15_0 = input.LA(1);

					if ((LA15_0==COMA))
					{
						alt15 = 1;
					}


					} finally { DebugExitDecision(15); }
					switch ( alt15 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:84:58: COMA ! expr
						{
						DebugLocation(84, 62);
						COMA96=(IToken)Match(input,COMA,Follow._COMA_in_dispatch710); 
						DebugLocation(84, 64);
						PushFollow(Follow._expr_in_dispatch713);
						expr97=expr();
						PopFollow();

						adaptor.AddChild(root_0, expr97.Tree);

						}
						break;

					default:
						goto loop15;
					}
				}

				loop15:
					;

				} finally { DebugExitSubRule(15); }


				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(84, 82);
			CL_PARENT98=(IToken)Match(input,CL_PARENT,Follow._CL_PARENT_in_dispatch719); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dispatch", 22);
			LeaveRule("dispatch", 22);
			LeaveRule_dispatch();
		}
		DebugLocation(84, 83);
		} finally { DebugExitRule(GrammarFileName, "dispatch"); }
		return retval;

	}
	// $ANTLR end "dispatch"

	partial void EnterRule_exprlist1();
	partial void LeaveRule_exprlist1();

	// $ANTLR start "exprlist1"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:85:2: exprlist1 : ( expr ( COMA ! expr )* )? ;
	[GrammarRule("exprlist1")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> exprlist1()
	{
		EnterRule_exprlist1();
		EnterRule("exprlist1", 23);
		TraceIn("exprlist1", 23);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken COMA100 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr99 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr101 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree COMA100_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "exprlist1");
		DebugLocation(85, 26);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:86:3: ( ( expr ( COMA ! expr )* )? )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:86:5: ( expr ( COMA ! expr )* )?
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(86, 5);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:86:5: ( expr ( COMA ! expr )* )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_0 = input.LA(1);

			if (((LA18_0>=BOOLEAN && LA18_0<=CASE)||(LA18_0>=ID && LA18_0<=IF)||LA18_0==ISVOID||LA18_0==LET||(LA18_0>=NANARITA && LA18_0<=NEW)||(LA18_0>=NOT && LA18_0<=NUMBER)||(LA18_0>=OP_LLAVE && LA18_0<=OP_PARENT)||LA18_0==STRING||LA18_0==TYPE||LA18_0==WHILE))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:86:6: expr ( COMA ! expr )*
				{
				DebugLocation(86, 6);
				PushFollow(Follow._expr_in_exprlist1732);
				expr99=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr99.Tree);
				DebugLocation(86, 11);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:86:11: ( COMA ! expr )*
				try { DebugEnterSubRule(17);
				while (true)
				{
					int alt17=2;
					try { DebugEnterDecision(17, false);
					int LA17_0 = input.LA(1);

					if ((LA17_0==COMA))
					{
						alt17 = 1;
					}


					} finally { DebugExitDecision(17); }
					switch ( alt17 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:86:13: COMA ! expr
						{
						DebugLocation(86, 17);
						COMA100=(IToken)Match(input,COMA,Follow._COMA_in_exprlist1736); 
						DebugLocation(86, 19);
						PushFollow(Follow._expr_in_exprlist1739);
						expr101=expr();
						PopFollow();

						adaptor.AddChild(root_0, expr101.Tree);

						}
						break;

					default:
						goto loop17;
					}
				}

				loop17:
					;

				} finally { DebugExitSubRule(17); }


				}
				break;

			}
			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exprlist1", 23);
			LeaveRule("exprlist1", 23);
			LeaveRule_exprlist1();
		}
		DebugLocation(86, 26);
		} finally { DebugExitRule(GrammarFileName, "exprlist1"); }
		return retval;

	}
	// $ANTLR end "exprlist1"

	partial void EnterRule_dispatch2();
	partial void LeaveRule_dispatch2();

	// $ANTLR start "dispatch2"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:89:2: dispatch2 : OP_PARENT ( expr ( COMA ! expr )* )? CL_PARENT !;
	[GrammarRule("dispatch2")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> dispatch2()
	{
		EnterRule_dispatch2();
		EnterRule("dispatch2", 24);
		TraceIn("dispatch2", 24);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken OP_PARENT102 = default(IToken);
		IToken COMA104 = default(IToken);
		IToken CL_PARENT106 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr103 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr105 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree OP_PARENT102_tree = default(COOLCommonTree);
		COOLCommonTree COMA104_tree = default(COOLCommonTree);
		COOLCommonTree CL_PARENT106_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "dispatch2");
		DebugLocation(89, 49);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:90:3: ( OP_PARENT ( expr ( COMA ! expr )* )? CL_PARENT !)
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:90:6: OP_PARENT ( expr ( COMA ! expr )* )? CL_PARENT !
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(90, 6);
			OP_PARENT102=(IToken)Match(input,OP_PARENT,Follow._OP_PARENT_in_dispatch2759); 
			OP_PARENT102_tree = (COOLCommonTree)adaptor.Create(OP_PARENT102);
			adaptor.AddChild(root_0, OP_PARENT102_tree);
			DebugLocation(90, 16);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:90:16: ( expr ( COMA ! expr )* )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_0 = input.LA(1);

			if (((LA20_0>=BOOLEAN && LA20_0<=CASE)||(LA20_0>=ID && LA20_0<=IF)||LA20_0==ISVOID||LA20_0==LET||(LA20_0>=NANARITA && LA20_0<=NEW)||(LA20_0>=NOT && LA20_0<=NUMBER)||(LA20_0>=OP_LLAVE && LA20_0<=OP_PARENT)||LA20_0==STRING||LA20_0==TYPE||LA20_0==WHILE))
			{
				alt20 = 1;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:90:17: expr ( COMA ! expr )*
				{
				DebugLocation(90, 17);
				PushFollow(Follow._expr_in_dispatch2762);
				expr103=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr103.Tree);
				DebugLocation(90, 22);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:90:22: ( COMA ! expr )*
				try { DebugEnterSubRule(19);
				while (true)
				{
					int alt19=2;
					try { DebugEnterDecision(19, false);
					int LA19_0 = input.LA(1);

					if ((LA19_0==COMA))
					{
						alt19 = 1;
					}


					} finally { DebugExitDecision(19); }
					switch ( alt19 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:90:24: COMA ! expr
						{
						DebugLocation(90, 28);
						COMA104=(IToken)Match(input,COMA,Follow._COMA_in_dispatch2766); 
						DebugLocation(90, 30);
						PushFollow(Follow._expr_in_dispatch2769);
						expr105=expr();
						PopFollow();

						adaptor.AddChild(root_0, expr105.Tree);

						}
						break;

					default:
						goto loop19;
					}
				}

				loop19:
					;

				} finally { DebugExitSubRule(19); }


				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(90, 48);
			CL_PARENT106=(IToken)Match(input,CL_PARENT,Follow._CL_PARENT_in_dispatch2775); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dispatch2", 24);
			LeaveRule("dispatch2", 24);
			LeaveRule_dispatch2();
		}
		DebugLocation(90, 49);
		} finally { DebugExitRule(GrammarFileName, "dispatch2"); }
		return retval;

	}
	// $ANTLR end "dispatch2"

	partial void EnterRule_operations();
	partial void LeaveRule_operations();

	// $ANTLR start "operations"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:91:2: operations : lv1 ;
	[GrammarRule("operations")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> operations()
	{
		EnterRule_operations();
		EnterRule("operations", 25);
		TraceIn("operations", 25);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		AstParserRuleReturnScope<COOLCommonTree, IToken> lv1107 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "operations");
		DebugLocation(91, 9);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:92:3: ( lv1 )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:92:6: lv1
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(92, 6);
			PushFollow(Follow._lv1_in_operations788);
			lv1107=lv1();
			PopFollow();

			adaptor.AddChild(root_0, lv1107.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operations", 25);
			LeaveRule("operations", 25);
			LeaveRule_operations();
		}
		DebugLocation(92, 9);
		} finally { DebugExitRule(GrammarFileName, "operations"); }
		return retval;

	}
	// $ANTLR end "operations"

	partial void EnterRule_lv1();
	partial void LeaveRule_lv1();

	// $ANTLR start "lv1"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:93:3: lv1 : lv2 ( LEQ ^ lv2 | GEQ ^ lv2 | L ^ lv2 | G ^ lv2 | EQ ^ lv2 )* ;
	[GrammarRule("lv1")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> lv1()
	{
		EnterRule_lv1();
		EnterRule("lv1", 26);
		TraceIn("lv1", 26);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken LEQ109 = default(IToken);
		IToken GEQ111 = default(IToken);
		IToken L113 = default(IToken);
		IToken G115 = default(IToken);
		IToken EQ117 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> lv2108 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> lv2110 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> lv2112 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> lv2114 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> lv2116 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> lv2118 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree LEQ109_tree = default(COOLCommonTree);
		COOLCommonTree GEQ111_tree = default(COOLCommonTree);
		COOLCommonTree L113_tree = default(COOLCommonTree);
		COOLCommonTree G115_tree = default(COOLCommonTree);
		COOLCommonTree EQ117_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "lv1");
		DebugLocation(93, 55);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:93:6: ( lv2 ( LEQ ^ lv2 | GEQ ^ lv2 | L ^ lv2 | G ^ lv2 | EQ ^ lv2 )* )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:93:9: lv2 ( LEQ ^ lv2 | GEQ ^ lv2 | L ^ lv2 | G ^ lv2 | EQ ^ lv2 )*
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(93, 9);
			PushFollow(Follow._lv2_in_lv1798);
			lv2108=lv2();
			PopFollow();

			adaptor.AddChild(root_0, lv2108.Tree);
			DebugLocation(93, 13);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:93:13: ( LEQ ^ lv2 | GEQ ^ lv2 | L ^ lv2 | G ^ lv2 | EQ ^ lv2 )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=6;
				try { DebugEnterDecision(21, false);
				switch (input.LA(1))
				{
				case LEQ:
					{
					alt21 = 1;
					}
					break;
				case GEQ:
					{
					alt21 = 2;
					}
					break;
				case L:
					{
					alt21 = 3;
					}
					break;
				case G:
					{
					alt21 = 4;
					}
					break;
				case EQ:
					{
					alt21 = 5;
					}
					break;
				}

				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:93:15: LEQ ^ lv2
					{
					DebugLocation(93, 18);
					LEQ109=(IToken)Match(input,LEQ,Follow._LEQ_in_lv1802); 
					LEQ109_tree = (COOLCommonTree)adaptor.Create(LEQ109);
					root_0 = (COOLCommonTree)adaptor.BecomeRoot(LEQ109_tree, root_0);
					DebugLocation(93, 20);
					PushFollow(Follow._lv2_in_lv1805);
					lv2110=lv2();
					PopFollow();

					adaptor.AddChild(root_0, lv2110.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:93:24: GEQ ^ lv2
					{
					DebugLocation(93, 27);
					GEQ111=(IToken)Match(input,GEQ,Follow._GEQ_in_lv1807); 
					GEQ111_tree = (COOLCommonTree)adaptor.Create(GEQ111);
					root_0 = (COOLCommonTree)adaptor.BecomeRoot(GEQ111_tree, root_0);
					DebugLocation(93, 29);
					PushFollow(Follow._lv2_in_lv1810);
					lv2112=lv2();
					PopFollow();

					adaptor.AddChild(root_0, lv2112.Tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:93:33: L ^ lv2
					{
					DebugLocation(93, 34);
					L113=(IToken)Match(input,L,Follow._L_in_lv1812); 
					L113_tree = (COOLCommonTree)adaptor.Create(L113);
					root_0 = (COOLCommonTree)adaptor.BecomeRoot(L113_tree, root_0);
					DebugLocation(93, 36);
					PushFollow(Follow._lv2_in_lv1815);
					lv2114=lv2();
					PopFollow();

					adaptor.AddChild(root_0, lv2114.Tree);

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:93:40: G ^ lv2
					{
					DebugLocation(93, 41);
					G115=(IToken)Match(input,G,Follow._G_in_lv1817); 
					G115_tree = (COOLCommonTree)adaptor.Create(G115);
					root_0 = (COOLCommonTree)adaptor.BecomeRoot(G115_tree, root_0);
					DebugLocation(93, 43);
					PushFollow(Follow._lv2_in_lv1820);
					lv2116=lv2();
					PopFollow();

					adaptor.AddChild(root_0, lv2116.Tree);

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:93:47: EQ ^ lv2
					{
					DebugLocation(93, 49);
					EQ117=(IToken)Match(input,EQ,Follow._EQ_in_lv1822); 
					EQ117_tree = (COOLCommonTree)adaptor.Create(EQ117);
					root_0 = (COOLCommonTree)adaptor.BecomeRoot(EQ117_tree, root_0);
					DebugLocation(93, 51);
					PushFollow(Follow._lv2_in_lv1825);
					lv2118=lv2();
					PopFollow();

					adaptor.AddChild(root_0, lv2118.Tree);

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lv1", 26);
			LeaveRule("lv1", 26);
			LeaveRule_lv1();
		}
		DebugLocation(93, 55);
		} finally { DebugExitRule(GrammarFileName, "lv1"); }
		return retval;

	}
	// $ANTLR end "lv1"

	partial void EnterRule_lv2();
	partial void LeaveRule_lv2();

	// $ANTLR start "lv2"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:94:3: lv2 : lv3 ( PLUS ^ lv3 | MINUS ^ lv3 )* ;
	[GrammarRule("lv2")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> lv2()
	{
		EnterRule_lv2();
		EnterRule("lv2", 27);
		TraceIn("lv2", 27);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken PLUS120 = default(IToken);
		IToken MINUS122 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> lv3119 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> lv3121 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> lv3123 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree PLUS120_tree = default(COOLCommonTree);
		COOLCommonTree MINUS122_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "lv2");
		DebugLocation(94, 38);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:94:6: ( lv3 ( PLUS ^ lv3 | MINUS ^ lv3 )* )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:94:8: lv3 ( PLUS ^ lv3 | MINUS ^ lv3 )*
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(94, 8);
			PushFollow(Follow._lv3_in_lv2835);
			lv3119=lv3();
			PopFollow();

			adaptor.AddChild(root_0, lv3119.Tree);
			DebugLocation(94, 12);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:94:12: ( PLUS ^ lv3 | MINUS ^ lv3 )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=3;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==PLUS))
				{
					alt22 = 1;
				}
				else if ((LA22_0==MINUS))
				{
					alt22 = 2;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:94:14: PLUS ^ lv3
					{
					DebugLocation(94, 18);
					PLUS120=(IToken)Match(input,PLUS,Follow._PLUS_in_lv2839); 
					PLUS120_tree = (COOLCommonTree)adaptor.Create(PLUS120);
					root_0 = (COOLCommonTree)adaptor.BecomeRoot(PLUS120_tree, root_0);
					DebugLocation(94, 21);
					PushFollow(Follow._lv3_in_lv2843);
					lv3121=lv3();
					PopFollow();

					adaptor.AddChild(root_0, lv3121.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:94:25: MINUS ^ lv3
					{
					DebugLocation(94, 30);
					MINUS122=(IToken)Match(input,MINUS,Follow._MINUS_in_lv2845); 
					MINUS122_tree = (COOLCommonTree)adaptor.Create(MINUS122);
					root_0 = (COOLCommonTree)adaptor.BecomeRoot(MINUS122_tree, root_0);
					DebugLocation(94, 33);
					PushFollow(Follow._lv3_in_lv2849);
					lv3123=lv3();
					PopFollow();

					adaptor.AddChild(root_0, lv3123.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lv2", 27);
			LeaveRule("lv2", 27);
			LeaveRule_lv2();
		}
		DebugLocation(94, 38);
		} finally { DebugExitRule(GrammarFileName, "lv2"); }
		return retval;

	}
	// $ANTLR end "lv2"

	partial void EnterRule_lv3();
	partial void LeaveRule_lv3();

	// $ANTLR start "lv3"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:95:3: lv3 : lv4 ( MULT ^ lv4 | DIV ^ lv4 )* ;
	[GrammarRule("lv3")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> lv3()
	{
		EnterRule_lv3();
		EnterRule("lv3", 28);
		TraceIn("lv3", 28);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken MULT125 = default(IToken);
		IToken DIV127 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> lv4124 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> lv4126 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> lv4128 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree MULT125_tree = default(COOLCommonTree);
		COOLCommonTree DIV127_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "lv3");
		DebugLocation(95, 35);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:95:6: ( lv4 ( MULT ^ lv4 | DIV ^ lv4 )* )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:95:8: lv4 ( MULT ^ lv4 | DIV ^ lv4 )*
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(95, 8);
			PushFollow(Follow._lv4_in_lv3860);
			lv4124=lv4();
			PopFollow();

			adaptor.AddChild(root_0, lv4124.Tree);
			DebugLocation(95, 11);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:95:11: ( MULT ^ lv4 | DIV ^ lv4 )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=3;
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==MULT))
				{
					alt23 = 1;
				}
				else if ((LA23_0==DIV))
				{
					alt23 = 2;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:95:13: MULT ^ lv4
					{
					DebugLocation(95, 17);
					MULT125=(IToken)Match(input,MULT,Follow._MULT_in_lv3863); 
					MULT125_tree = (COOLCommonTree)adaptor.Create(MULT125);
					root_0 = (COOLCommonTree)adaptor.BecomeRoot(MULT125_tree, root_0);
					DebugLocation(95, 20);
					PushFollow(Follow._lv4_in_lv3867);
					lv4126=lv4();
					PopFollow();

					adaptor.AddChild(root_0, lv4126.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:95:24: DIV ^ lv4
					{
					DebugLocation(95, 27);
					DIV127=(IToken)Match(input,DIV,Follow._DIV_in_lv3869); 
					DIV127_tree = (COOLCommonTree)adaptor.Create(DIV127);
					root_0 = (COOLCommonTree)adaptor.BecomeRoot(DIV127_tree, root_0);
					DebugLocation(95, 30);
					PushFollow(Follow._lv4_in_lv3873);
					lv4128=lv4();
					PopFollow();

					adaptor.AddChild(root_0, lv4128.Tree);

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lv3", 28);
			LeaveRule("lv3", 28);
			LeaveRule_lv3();
		}
		DebugLocation(95, 35);
		} finally { DebugExitRule(GrammarFileName, "lv3"); }
		return retval;

	}
	// $ANTLR end "lv3"

	partial void EnterRule_lv4();
	partial void LeaveRule_lv4();

	// $ANTLR start "lv4"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:96:3: lv4 : lv5 ;
	[GrammarRule("lv4")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> lv4()
	{
		EnterRule_lv4();
		EnterRule("lv4", 29);
		TraceIn("lv4", 29);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		AstParserRuleReturnScope<COOLCommonTree, IToken> lv5129 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "lv4");
		DebugLocation(96, 11);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:96:6: ( lv5 )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:96:8: lv5
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(96, 8);
			PushFollow(Follow._lv5_in_lv4884);
			lv5129=lv5();
			PopFollow();

			adaptor.AddChild(root_0, lv5129.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lv4", 29);
			LeaveRule("lv4", 29);
			LeaveRule_lv4();
		}
		DebugLocation(96, 11);
		} finally { DebugExitRule(GrammarFileName, "lv4"); }
		return retval;

	}
	// $ANTLR end "lv4"

	partial void EnterRule_lv5();
	partial void LeaveRule_lv5();

	// $ANTLR start "lv5"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:97:3: lv5 : ( ( NANARITA ( lv6 ) ) -> ^( NANARITA lv6 ) | lv6 );
	[GrammarRule("lv5")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> lv5()
	{
		EnterRule_lv5();
		EnterRule("lv5", 30);
		TraceIn("lv5", 30);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken NANARITA130 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> lv6131 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> lv6132 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree NANARITA130_tree = default(COOLCommonTree);
		RewriteRuleITokenStream stream_NANARITA=new RewriteRuleITokenStream(adaptor,"token NANARITA");
		RewriteRuleSubtreeStream stream_lv6=new RewriteRuleSubtreeStream(adaptor,"rule lv6");
		try { DebugEnterRule(GrammarFileName, "lv5");
		DebugLocation(97, 49);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:97:6: ( ( NANARITA ( lv6 ) ) -> ^( NANARITA lv6 ) | lv6 )
			int alt24=2;
			try { DebugEnterDecision(24, false);
			int LA24_0 = input.LA(1);

			if ((LA24_0==NANARITA))
			{
				alt24 = 1;
			}
			else if ((LA24_0==BOOLEAN||(LA24_0>=ID && LA24_0<=IF)||LA24_0==NUMBER||LA24_0==OP_PARENT||LA24_0==STRING||LA24_0==WHILE))
			{
				alt24 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:97:8: ( NANARITA ( lv6 ) )
				{
				DebugLocation(97, 8);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:97:8: ( NANARITA ( lv6 ) )
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:97:9: NANARITA ( lv6 )
				{
				DebugLocation(97, 9);
				NANARITA130=(IToken)Match(input,NANARITA,Follow._NANARITA_in_lv5894);  
				stream_NANARITA.Add(NANARITA130);

				DebugLocation(97, 18);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:97:18: ( lv6 )
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:97:19: lv6
				{
				DebugLocation(97, 19);
				PushFollow(Follow._lv6_in_lv5897);
				lv6131=lv6();
				PopFollow();

				stream_lv6.Add(lv6131.Tree);

				}


				}



				{
				// AST REWRITE
				// elements: lv6, NANARITA
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (COOLCommonTree)adaptor.Nil();
				// 97:24: -> ^( NANARITA lv6 )
				{
					DebugLocation(97, 27);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:97:27: ^( NANARITA lv6 )
					{
					COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
					DebugLocation(97, 29);
					root_1 = (COOLCommonTree)adaptor.BecomeRoot(stream_NANARITA.NextNode(), root_1);

					DebugLocation(97, 38);
					adaptor.AddChild(root_1, stream_lv6.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:97:45: lv6
				{
				root_0 = (COOLCommonTree)adaptor.Nil();

				DebugLocation(97, 45);
				PushFollow(Follow._lv6_in_lv5910);
				lv6132=lv6();
				PopFollow();

				adaptor.AddChild(root_0, lv6132.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lv5", 30);
			LeaveRule("lv5", 30);
			LeaveRule_lv5();
		}
		DebugLocation(97, 49);
		} finally { DebugExitRule(GrammarFileName, "lv5"); }
		return retval;

	}
	// $ANTLR end "lv5"

	partial void EnterRule_lv6();
	partial void LeaveRule_lv6();

	// $ANTLR start "lv6"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:98:3: lv6 : ( ( ( ID -> ID ) ( dispatchrec -> ^( DISPATCH $lv6 dispatchrec ) )? | ( tmp2 -> tmp2 ) ( dispatchrec -> ^( DISPATCH $lv6 dispatchrec ) )? | ( constant -> constant ) ( dispatchrec )? ) | conditionals | loops );
	[GrammarRule("lv6")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> lv6()
	{
		EnterRule_lv6();
		EnterRule("lv6", 31);
		TraceIn("lv6", 31);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken ID133 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> dispatchrec134 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> tmp2135 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> dispatchrec136 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> constant137 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> dispatchrec138 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> conditionals139 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> loops140 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree ID133_tree = default(COOLCommonTree);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_tmp2=new RewriteRuleSubtreeStream(adaptor,"rule tmp2");
		RewriteRuleSubtreeStream stream_constant=new RewriteRuleSubtreeStream(adaptor,"rule constant");
		RewriteRuleSubtreeStream stream_dispatchrec=new RewriteRuleSubtreeStream(adaptor,"rule dispatchrec");
		try { DebugEnterRule(GrammarFileName, "lv6");
		DebugLocation(98, 3);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:98:6: ( ( ( ID -> ID ) ( dispatchrec -> ^( DISPATCH $lv6 dispatchrec ) )? | ( tmp2 -> tmp2 ) ( dispatchrec -> ^( DISPATCH $lv6 dispatchrec ) )? | ( constant -> constant ) ( dispatchrec )? ) | conditionals | loops )
			int alt29=3;
			try { DebugEnterDecision(29, false);
			switch (input.LA(1))
			{
			case BOOLEAN:
			case ID:
			case NUMBER:
			case OP_PARENT:
			case STRING:
				{
				alt29 = 1;
				}
				break;
			case IF:
				{
				alt29 = 2;
				}
				break;
			case WHILE:
				{
				alt29 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 29, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:98:8: ( ( ID -> ID ) ( dispatchrec -> ^( DISPATCH $lv6 dispatchrec ) )? | ( tmp2 -> tmp2 ) ( dispatchrec -> ^( DISPATCH $lv6 dispatchrec ) )? | ( constant -> constant ) ( dispatchrec )? )
				{
				DebugLocation(98, 8);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:98:8: ( ( ID -> ID ) ( dispatchrec -> ^( DISPATCH $lv6 dispatchrec ) )? | ( tmp2 -> tmp2 ) ( dispatchrec -> ^( DISPATCH $lv6 dispatchrec ) )? | ( constant -> constant ) ( dispatchrec )? )
				int alt28=3;
				try { DebugEnterSubRule(28);
				try { DebugEnterDecision(28, false);
				switch (input.LA(1))
				{
				case ID:
					{
					alt28 = 1;
					}
					break;
				case OP_PARENT:
					{
					alt28 = 2;
					}
					break;
				case BOOLEAN:
				case NUMBER:
				case STRING:
					{
					alt28 = 3;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(28); }
				switch (alt28)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:98:9: ( ID -> ID ) ( dispatchrec -> ^( DISPATCH $lv6 dispatchrec ) )?
					{
					DebugLocation(98, 9);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:98:9: ( ID -> ID )
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:98:10: ID
					{
					DebugLocation(98, 10);
					ID133=(IToken)Match(input,ID,Follow._ID_in_lv6922);  
					stream_ID.Add(ID133);



					{
					// AST REWRITE
					// elements: ID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (COOLCommonTree)adaptor.Nil();
					// 98:12: -> ID
					{
						DebugLocation(98, 14);
						adaptor.AddChild(root_0, stream_ID.NextNode());

					}

					retval.Tree = root_0;
					}

					}

					DebugLocation(98, 18);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:98:18: ( dispatchrec -> ^( DISPATCH $lv6 dispatchrec ) )?
					int alt25=2;
					try { DebugEnterSubRule(25);
					try { DebugEnterDecision(25, false);
					int LA25_0 = input.LA(1);

					if ((LA25_0==ARROBA||LA25_0==OP_PARENT||LA25_0==PNT))
					{
						alt25 = 1;
					}
					} finally { DebugExitDecision(25); }
					switch (alt25)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:98:19: dispatchrec
						{
						DebugLocation(98, 19);
						PushFollow(Follow._dispatchrec_in_lv6928);
						dispatchrec134=dispatchrec();
						PopFollow();

						stream_dispatchrec.Add(dispatchrec134.Tree);


						{
						// AST REWRITE
						// elements: dispatchrec, lv6
						// token labels: 
						// rule labels: retval
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

						root_0 = (COOLCommonTree)adaptor.Nil();
						// 98:30: -> ^( DISPATCH $lv6 dispatchrec )
						{
							DebugLocation(98, 32);
							// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:98:32: ^( DISPATCH $lv6 dispatchrec )
							{
							COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
							DebugLocation(98, 34);
							root_1 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(DISPATCH, "DISPATCH"), root_1);

							DebugLocation(98, 44);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(98, 48);
							adaptor.AddChild(root_1, stream_dispatchrec.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}

						}
						break;

					}
					} finally { DebugExitSubRule(25); }


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:99:4: ( tmp2 -> tmp2 ) ( dispatchrec -> ^( DISPATCH $lv6 dispatchrec ) )?
					{
					DebugLocation(99, 4);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:99:4: ( tmp2 -> tmp2 )
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:99:5: tmp2
					{
					DebugLocation(99, 5);
					PushFollow(Follow._tmp2_in_lv6945);
					tmp2135=tmp2();
					PopFollow();

					stream_tmp2.Add(tmp2135.Tree);


					{
					// AST REWRITE
					// elements: tmp2
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (COOLCommonTree)adaptor.Nil();
					// 99:9: -> tmp2
					{
						DebugLocation(99, 11);
						adaptor.AddChild(root_0, stream_tmp2.NextTree());

					}

					retval.Tree = root_0;
					}

					}

					DebugLocation(99, 17);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:99:17: ( dispatchrec -> ^( DISPATCH $lv6 dispatchrec ) )?
					int alt26=2;
					try { DebugEnterSubRule(26);
					try { DebugEnterDecision(26, false);
					int LA26_0 = input.LA(1);

					if ((LA26_0==ARROBA||LA26_0==OP_PARENT||LA26_0==PNT))
					{
						alt26 = 1;
					}
					} finally { DebugExitDecision(26); }
					switch (alt26)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:99:18: dispatchrec
						{
						DebugLocation(99, 18);
						PushFollow(Follow._dispatchrec_in_lv6951);
						dispatchrec136=dispatchrec();
						PopFollow();

						stream_dispatchrec.Add(dispatchrec136.Tree);


						{
						// AST REWRITE
						// elements: lv6, dispatchrec
						// token labels: 
						// rule labels: retval
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

						root_0 = (COOLCommonTree)adaptor.Nil();
						// 99:29: -> ^( DISPATCH $lv6 dispatchrec )
						{
							DebugLocation(99, 31);
							// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:99:31: ^( DISPATCH $lv6 dispatchrec )
							{
							COOLCommonTree root_1 = (COOLCommonTree)adaptor.Nil();
							DebugLocation(99, 33);
							root_1 = (COOLCommonTree)adaptor.BecomeRoot((COOLCommonTree)adaptor.Create(DISPATCH, "DISPATCH"), root_1);

							DebugLocation(99, 43);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(99, 47);
							adaptor.AddChild(root_1, stream_dispatchrec.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}

						}
						break;

					}
					} finally { DebugExitSubRule(26); }


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:100:4: ( constant -> constant ) ( dispatchrec )?
					{
					DebugLocation(100, 4);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:100:4: ( constant -> constant )
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:100:5: constant
					{
					DebugLocation(100, 5);
					PushFollow(Follow._constant_in_lv6968);
					constant137=constant();
					PopFollow();

					stream_constant.Add(constant137.Tree);


					{
					// AST REWRITE
					// elements: constant
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (COOLCommonTree)adaptor.Nil();
					// 100:13: -> constant
					{
						DebugLocation(100, 15);
						adaptor.AddChild(root_0, stream_constant.NextTree());

					}

					retval.Tree = root_0;
					}

					}

					DebugLocation(100, 25);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:100:25: ( dispatchrec )?
					int alt27=2;
					try { DebugEnterSubRule(27);
					try { DebugEnterDecision(27, false);
					int LA27_0 = input.LA(1);

					if ((LA27_0==ARROBA||LA27_0==OP_PARENT||LA27_0==PNT))
					{
						alt27 = 1;
					}
					} finally { DebugExitDecision(27); }
					switch (alt27)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:100:25: dispatchrec
						{
						DebugLocation(100, 25);
						PushFollow(Follow._dispatchrec_in_lv6973);
						dispatchrec138=dispatchrec();
						PopFollow();

						stream_dispatchrec.Add(dispatchrec138.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(27); }


					}
					break;

				}
				} finally { DebugExitSubRule(28); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:100:40: conditionals
				{
				root_0 = (COOLCommonTree)adaptor.Nil();

				DebugLocation(100, 40);
				PushFollow(Follow._conditionals_in_lv6978);
				conditionals139=conditionals();
				PopFollow();

				adaptor.AddChild(root_0, conditionals139.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:101:6: loops
				{
				root_0 = (COOLCommonTree)adaptor.Nil();

				DebugLocation(101, 6);
				PushFollow(Follow._loops_in_lv6985);
				loops140=loops();
				PopFollow();

				adaptor.AddChild(root_0, loops140.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lv6", 31);
			LeaveRule("lv6", 31);
			LeaveRule_lv6();
		}
		DebugLocation(102, 3);
		} finally { DebugExitRule(GrammarFileName, "lv6"); }
		return retval;

	}
	// $ANTLR end "lv6"

	partial void EnterRule_tmp2();
	partial void LeaveRule_tmp2();

	// $ANTLR start "tmp2"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:104:3: tmp2 : OP_PARENT ! expr CL_PARENT !;
	[GrammarRule("tmp2")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> tmp2()
	{
		EnterRule_tmp2();
		EnterRule("tmp2", 32);
		TraceIn("tmp2", 32);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken OP_PARENT141 = default(IToken);
		IToken CL_PARENT143 = default(IToken);
		AstParserRuleReturnScope<COOLCommonTree, IToken> expr142 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		COOLCommonTree OP_PARENT141_tree = default(COOLCommonTree);
		COOLCommonTree CL_PARENT143_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "tmp2");
		DebugLocation(104, 34);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:104:7: ( OP_PARENT ! expr CL_PARENT !)
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:104:9: OP_PARENT ! expr CL_PARENT !
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(104, 18);
			OP_PARENT141=(IToken)Match(input,OP_PARENT,Follow._OP_PARENT_in_tmp21000); 
			DebugLocation(104, 20);
			PushFollow(Follow._expr_in_tmp21003);
			expr142=expr();
			PopFollow();

			adaptor.AddChild(root_0, expr142.Tree);
			DebugLocation(104, 34);
			CL_PARENT143=(IToken)Match(input,CL_PARENT,Follow._CL_PARENT_in_tmp21005); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tmp2", 32);
			LeaveRule("tmp2", 32);
			LeaveRule_tmp2();
		}
		DebugLocation(104, 34);
		} finally { DebugExitRule(GrammarFileName, "tmp2"); }
		return retval;

	}
	// $ANTLR end "tmp2"

	partial void EnterRule_tmp();
	partial void LeaveRule_tmp();

	// $ANTLR start "tmp"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:105:3: tmp : ( dispatch | dispatch2 ) ( dispatchrec )? ;
	[GrammarRule("tmp")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> tmp()
	{
		EnterRule_tmp();
		EnterRule("tmp", 33);
		TraceIn("tmp", 33);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		AstParserRuleReturnScope<COOLCommonTree, IToken> dispatch144 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> dispatch2145 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);
		AstParserRuleReturnScope<COOLCommonTree, IToken> dispatchrec146 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "tmp");
		DebugLocation(105, 2);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:105:6: ( ( dispatch | dispatch2 ) ( dispatchrec )? )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:106:3: ( dispatch | dispatch2 ) ( dispatchrec )?
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(106, 3);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:106:3: ( dispatch | dispatch2 )
			int alt30=2;
			try { DebugEnterSubRule(30);
			try { DebugEnterDecision(30, false);
			int LA30_0 = input.LA(1);

			if ((LA30_0==ARROBA||LA30_0==PNT))
			{
				alt30 = 1;
			}
			else if ((LA30_0==OP_PARENT))
			{
				alt30 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 30, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:106:4: dispatch
				{
				DebugLocation(106, 4);
				PushFollow(Follow._dispatch_in_tmp1017);
				dispatch144=dispatch();
				PopFollow();

				adaptor.AddChild(root_0, dispatch144.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:106:13: dispatch2
				{
				DebugLocation(106, 13);
				PushFollow(Follow._dispatch2_in_tmp1019);
				dispatch2145=dispatch2();
				PopFollow();

				adaptor.AddChild(root_0, dispatch2145.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(30); }

			DebugLocation(106, 23);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:106:23: ( dispatchrec )?
			int alt31=2;
			try { DebugEnterSubRule(31);
			try { DebugEnterDecision(31, false);
			int LA31_0 = input.LA(1);

			if ((LA31_0==ARROBA||LA31_0==OP_PARENT||LA31_0==PNT))
			{
				alt31 = 1;
			}
			} finally { DebugExitDecision(31); }
			switch (alt31)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:106:25: dispatchrec
				{
				DebugLocation(106, 25);
				PushFollow(Follow._dispatchrec_in_tmp1023);
				dispatchrec146=dispatchrec();
				PopFollow();

				adaptor.AddChild(root_0, dispatchrec146.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(31); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tmp", 33);
			LeaveRule("tmp", 33);
			LeaveRule_tmp();
		}
		DebugLocation(107, 2);
		} finally { DebugExitRule(GrammarFileName, "tmp"); }
		return retval;

	}
	// $ANTLR end "tmp"

	partial void EnterRule_dispatchrec();
	partial void LeaveRule_dispatchrec();

	// $ANTLR start "dispatchrec"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:108:3: dispatchrec : tmp ;
	[GrammarRule("dispatchrec")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> dispatchrec()
	{
		EnterRule_dispatchrec();
		EnterRule("dispatchrec", 34);
		TraceIn("dispatchrec", 34);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		AstParserRuleReturnScope<COOLCommonTree, IToken> tmp147 = default(AstParserRuleReturnScope<COOLCommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "dispatchrec");
		DebugLocation(108, 17);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:108:14: ( tmp )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:108:15: tmp
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(108, 15);
			PushFollow(Follow._tmp_in_dispatchrec1035);
			tmp147=tmp();
			PopFollow();

			adaptor.AddChild(root_0, tmp147.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dispatchrec", 34);
			LeaveRule("dispatchrec", 34);
			LeaveRule_dispatchrec();
		}
		DebugLocation(108, 17);
		} finally { DebugExitRule(GrammarFileName, "dispatchrec"); }
		return retval;

	}
	// $ANTLR end "dispatchrec"

	partial void EnterRule_nanarita();
	partial void LeaveRule_nanarita();

	// $ANTLR start "nanarita"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:109:2: nanarita : NANARITA ^;
	[GrammarRule("nanarita")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> nanarita()
	{
		EnterRule_nanarita();
		EnterRule("nanarita", 35);
		TraceIn("nanarita", 35);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken NANARITA148 = default(IToken);

		COOLCommonTree NANARITA148_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "nanarita");
		DebugLocation(109, 21);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:109:10: ( NANARITA ^)
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:109:12: NANARITA ^
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(109, 20);
			NANARITA148=(IToken)Match(input,NANARITA,Follow._NANARITA_in_nanarita1042); 
			NANARITA148_tree = (COOLCommonTree)adaptor.Create(NANARITA148);
			root_0 = (COOLCommonTree)adaptor.BecomeRoot(NANARITA148_tree, root_0);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nanarita", 35);
			LeaveRule("nanarita", 35);
			LeaveRule_nanarita();
		}
		DebugLocation(109, 21);
		} finally { DebugExitRule(GrammarFileName, "nanarita"); }
		return retval;

	}
	// $ANTLR end "nanarita"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();

	// $ANTLR start "constant"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:110:3: constant : ( STRING | NUMBER | BOOLEAN );
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 36);
		TraceIn("constant", 36);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken set149 = default(IToken);

		COOLCommonTree set149_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(110, 33);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:110:11: ( STRING | NUMBER | BOOLEAN )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(110, 11);

			set149=(IToken)input.LT(1);
			if (input.LA(1)==BOOLEAN||input.LA(1)==NUMBER||input.LA(1)==STRING)
			{
				input.Consume();
				adaptor.AddChild(root_0, (COOLCommonTree)adaptor.Create(set149));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constant", 36);
			LeaveRule("constant", 36);
			LeaveRule_constant();
		}
		DebugLocation(110, 33);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_wsnl();
	partial void LeaveRule_wsnl();

	// $ANTLR start "wsnl"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:111:2: wsnl : ( WS | NL )+ ;
	[GrammarRule("wsnl")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> wsnl()
	{
		EnterRule_wsnl();
		EnterRule("wsnl", 37);
		TraceIn("wsnl", 37);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken set150 = default(IToken);

		COOLCommonTree set150_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "wsnl");
		DebugLocation(111, 17);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:111:7: ( ( WS | NL )+ )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:111:9: ( WS | NL )+
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(111, 9);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:111:9: ( WS | NL )+
			int cnt32=0;
			try { DebugEnterSubRule(32);
			while (true)
			{
				int alt32=2;
				try { DebugEnterDecision(32, false);
				int LA32_0 = input.LA(1);

				if ((LA32_0==NL||LA32_0==WS))
				{
					alt32 = 1;
				}


				} finally { DebugExitDecision(32); }
				switch (alt32)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:
					{
					DebugLocation(111, 9);

					set150=(IToken)input.LT(1);
					if (input.LA(1)==NL||input.LA(1)==WS)
					{
						input.Consume();
						adaptor.AddChild(root_0, (COOLCommonTree)adaptor.Create(set150));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}


					}
					break;

				default:
					if (cnt32 >= 1)
						goto loop32;

					EarlyExitException eee32 = new EarlyExitException( 32, input );
					DebugRecognitionException(eee32);
					throw eee32;
				}
				cnt32++;
			}
			loop32:
				;

			} finally { DebugExitSubRule(32); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("wsnl", 37);
			LeaveRule("wsnl", 37);
			LeaveRule_wsnl();
		}
		DebugLocation(111, 17);
		} finally { DebugExitRule(GrammarFileName, "wsnl"); }
		return retval;

	}
	// $ANTLR end "wsnl"

	partial void EnterRule_compileUnit();
	partial void LeaveRule_compileUnit();

	// $ANTLR start "compileUnit"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:112:1: compileUnit : EOF ;
	[GrammarRule("compileUnit")]
	private AstParserRuleReturnScope<COOLCommonTree, IToken> compileUnit()
	{
		EnterRule_compileUnit();
		EnterRule("compileUnit", 38);
		TraceIn("compileUnit", 38);
		AstParserRuleReturnScope<COOLCommonTree, IToken> retval = new AstParserRuleReturnScope<COOLCommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		COOLCommonTree root_0 = default(COOLCommonTree);

		IToken EOF151 = default(IToken);

		COOLCommonTree EOF151_tree = default(COOLCommonTree);
		try { DebugEnterRule(GrammarFileName, "compileUnit");
		DebugLocation(112, 1);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:113:2: ( EOF )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:113:4: EOF
			{
			root_0 = (COOLCommonTree)adaptor.Nil();

			DebugLocation(113, 4);
			EOF151=(IToken)Match(input,EOF,Follow._EOF_in_compileUnit1078); 
			EOF151_tree = (COOLCommonTree)adaptor.Create(EOF151);
			adaptor.AddChild(root_0, EOF151_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (COOLCommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (COOLCommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("compileUnit", 38);
			LeaveRule("compileUnit", 38);
			LeaveRule_compileUnit();
		}
		DebugLocation(114, 1);
		} finally { DebugExitRule(GrammarFileName, "compileUnit"); }
		return retval;

	}
	// $ANTLR end "compileUnit"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _class_in_program94 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _EOF_in_program98 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CLASS_in_class117 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _TYPE_in_class120 = new BitSet(new ulong[]{0x200008000000000UL});
		public static readonly BitSet _INHERITS_in_class123 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _TYPE_in_class125 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _OP_LLAVE_in_class129 = new BitSet(new ulong[]{0x800010000UL});
		public static readonly BitSet _feature_list_in_class134 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _CL_LLAVE_in_class138 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _END_in_class141 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _feature_in_feature_list153 = new BitSet(new ulong[]{0x800000002UL});
		public static readonly BitSet _ID_in_feature162 = new BitSet(new ulong[]{0x400000001000000UL});
		public static readonly BitSet _attribute_in_feature165 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _methodefinition_in_feature176 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _END_in_feature188 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOUBLEP_in_attribute199 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _TYPE_in_attribute202 = new BitSet(new ulong[]{0x42UL});
		public static readonly BitSet _ASSING_in_attribute205 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_attribute207 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_PARENT_in_methodefinition218 = new BitSet(new ulong[]{0x800020000UL});
		public static readonly BitSet _params_list_in_methodefinition221 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _CL_PARENT_in_methodefinition227 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _DOUBLEP_in_methodefinition230 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _TYPE_in_methodefinition233 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _OP_LLAVE_in_methodefinition236 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_methodefinition239 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _CL_LLAVE_in_methodefinition242 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _param_in_params_list265 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _COMA_in_params_list268 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _param_in_params_list271 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _ID_in_param290 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _DOUBLEP_in_param293 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _TYPE_in_param296 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignment_in_expr313 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _blocks_in_expr325 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _let_in_expr332 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _case_in_expr339 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _new_in_expr346 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operations_in_expr353 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPE_in_expr360 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_expr369 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_expr372 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ISVOID_in_expr381 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_expr385 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_exprList396 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _END_in_exprList398 = new BitSet(new ulong[]{0x66C091800000C02UL,0x10AUL});
		public static readonly BitSet _expr_in_exprList402 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _END_in_exprList404 = new BitSet(new ulong[]{0x66C091800000C02UL,0x10AUL});
		public static readonly BitSet _ID_in_assignment415 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _ASSING_in_assignment417 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_assignment421 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_conditionals431 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_conditionals433 = new BitSet(new ulong[]{0x0UL,0x4UL});
		public static readonly BitSet _THEN_in_conditionals436 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_conditionals438 = new BitSet(new ulong[]{0x82000000UL});
		public static readonly BitSet _ELSE_in_conditionals442 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_conditionals444 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _FI_in_conditionals448 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_loops476 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_loops480 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _LOOP_in_loops482 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_loops485 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _POOL_in_loops487 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_LLAVE_in_blocks496 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _exprList_in_blocks499 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _CL_LLAVE_in_blocks501 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LET_in_let516 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _var_list_declaration_in_let519 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _IN_in_let521 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_let523 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_vardeclaration547 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _attribute_in_vardeclaration549 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _vardeclaration_in_var_list_declaration570 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _COMA_in_var_list_declaration577 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _vardeclaration_in_var_list_declaration579 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _CASE_in_case598 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_case601 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _OF_in_case603 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _caseBranches_in_case606 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _ESAC_in_case608 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _param_in_caseBranch620 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _IMPLICS_in_caseBranch622 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_caseBranch624 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _END_in_caseBranch626 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _caseBranch_in_caseBranches646 = new BitSet(new ulong[]{0x800000002UL});
		public static readonly BitSet _caseBranch_in_caseBranches652 = new BitSet(new ulong[]{0x800000002UL});
		public static readonly BitSet _NEW_in_new674 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _TYPE_in_new677 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ARROBA_in_dispatch689 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _TYPE_in_dispatch692 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _PNT_in_dispatch694 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _PNT_in_dispatch697 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _ID_in_dispatch701 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _OP_PARENT_in_dispatch703 = new BitSet(new ulong[]{0x66C091800020C00UL,0x10AUL});
		public static readonly BitSet _expr_in_dispatch706 = new BitSet(new ulong[]{0x60000UL});
		public static readonly BitSet _COMA_in_dispatch710 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_dispatch713 = new BitSet(new ulong[]{0x60000UL});
		public static readonly BitSet _CL_PARENT_in_dispatch719 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_exprlist1732 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _COMA_in_exprlist1736 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_exprlist1739 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _OP_PARENT_in_dispatch2759 = new BitSet(new ulong[]{0x66C091800020C00UL,0x10AUL});
		public static readonly BitSet _expr_in_dispatch2762 = new BitSet(new ulong[]{0x60000UL});
		public static readonly BitSet _COMA_in_dispatch2766 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_dispatch2769 = new BitSet(new ulong[]{0x60000UL});
		public static readonly BitSet _CL_PARENT_in_dispatch2775 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lv1_in_operations788 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lv2_in_lv1798 = new BitSet(new ulong[]{0x60308000002UL});
		public static readonly BitSet _LEQ_in_lv1802 = new BitSet(new ulong[]{0x444001800000400UL,0x102UL});
		public static readonly BitSet _lv2_in_lv1805 = new BitSet(new ulong[]{0x60308000002UL});
		public static readonly BitSet _GEQ_in_lv1807 = new BitSet(new ulong[]{0x444001800000400UL,0x102UL});
		public static readonly BitSet _lv2_in_lv1810 = new BitSet(new ulong[]{0x60308000002UL});
		public static readonly BitSet _L_in_lv1812 = new BitSet(new ulong[]{0x444001800000400UL,0x102UL});
		public static readonly BitSet _lv2_in_lv1815 = new BitSet(new ulong[]{0x60308000002UL});
		public static readonly BitSet _G_in_lv1817 = new BitSet(new ulong[]{0x444001800000400UL,0x102UL});
		public static readonly BitSet _lv2_in_lv1820 = new BitSet(new ulong[]{0x60308000002UL});
		public static readonly BitSet _EQ_in_lv1822 = new BitSet(new ulong[]{0x444001800000400UL,0x102UL});
		public static readonly BitSet _lv2_in_lv1825 = new BitSet(new ulong[]{0x60308000002UL});
		public static readonly BitSet _lv3_in_lv2835 = new BitSet(new ulong[]{0x2001000000000002UL});
		public static readonly BitSet _PLUS_in_lv2839 = new BitSet(new ulong[]{0x444001800000400UL,0x102UL});
		public static readonly BitSet _lv3_in_lv2843 = new BitSet(new ulong[]{0x2001000000000002UL});
		public static readonly BitSet _MINUS_in_lv2845 = new BitSet(new ulong[]{0x444001800000400UL,0x102UL});
		public static readonly BitSet _lv3_in_lv2849 = new BitSet(new ulong[]{0x2001000000000002UL});
		public static readonly BitSet _lv4_in_lv3860 = new BitSet(new ulong[]{0x2000000800002UL});
		public static readonly BitSet _MULT_in_lv3863 = new BitSet(new ulong[]{0x444001800000400UL,0x102UL});
		public static readonly BitSet _lv4_in_lv3867 = new BitSet(new ulong[]{0x2000000800002UL});
		public static readonly BitSet _DIV_in_lv3869 = new BitSet(new ulong[]{0x444001800000400UL,0x102UL});
		public static readonly BitSet _lv4_in_lv3873 = new BitSet(new ulong[]{0x2000000800002UL});
		public static readonly BitSet _lv5_in_lv4884 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NANARITA_in_lv5894 = new BitSet(new ulong[]{0x440001800000400UL,0x102UL});
		public static readonly BitSet _lv6_in_lv5897 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lv6_in_lv5910 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_lv6922 = new BitSet(new ulong[]{0x4400000000000012UL});
		public static readonly BitSet _dispatchrec_in_lv6928 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tmp2_in_lv6945 = new BitSet(new ulong[]{0x4400000000000012UL});
		public static readonly BitSet _dispatchrec_in_lv6951 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_lv6968 = new BitSet(new ulong[]{0x4400000000000012UL});
		public static readonly BitSet _dispatchrec_in_lv6973 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionals_in_lv6978 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _loops_in_lv6985 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_PARENT_in_tmp21000 = new BitSet(new ulong[]{0x66C091800000C00UL,0x10AUL});
		public static readonly BitSet _expr_in_tmp21003 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _CL_PARENT_in_tmp21005 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dispatch_in_tmp1017 = new BitSet(new ulong[]{0x4400000000000012UL});
		public static readonly BitSet _dispatch2_in_tmp1019 = new BitSet(new ulong[]{0x4400000000000012UL});
		public static readonly BitSet _dispatchrec_in_tmp1023 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tmp_in_dispatchrec1035 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NANARITA_in_nanarita1042 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOF_in_compileUnit1078 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
