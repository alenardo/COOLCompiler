//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g 2017-10-16 21:26:31

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class COOLParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ARROBA", "ASSING", "BOOLEAN", "CASE", "CHAR", "CLASS", "CL_CORCH", "CL_PARENT", "COMA", "COMMENT", "DIGIT", "DIV", "DOUBLEP", "ELSE", "END", "EQ", "ESAC", "ESC_SEQ", "EXPONENT", "FI", "G", "GEQ", "HEX_DIGIT", "ID", "IF", "IMPLICS", "IN", "INHERITS", "ISVOID", "L", "LEQ", "LET", "LOOP", "LOWERCASE", "MINUS", "MULT", "NANARITA", "NEW", "NL", "NOT", "NUMBER", "OCTAL_ESC", "OF", "OP_CORCH", "OP_PARENT", "PLUS", "PNT", "POOL", "STRING", "THEN", "TYPE", "UNICODE_ESC", "UPERCASE", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int ARROBA=4;
	public const int ASSING=5;
	public const int BOOLEAN=6;
	public const int CASE=7;
	public const int CHAR=8;
	public const int CLASS=9;
	public const int CL_CORCH=10;
	public const int CL_PARENT=11;
	public const int COMA=12;
	public const int COMMENT=13;
	public const int DIGIT=14;
	public const int DIV=15;
	public const int DOUBLEP=16;
	public const int ELSE=17;
	public const int END=18;
	public const int EQ=19;
	public const int ESAC=20;
	public const int ESC_SEQ=21;
	public const int EXPONENT=22;
	public const int FI=23;
	public const int G=24;
	public const int GEQ=25;
	public const int HEX_DIGIT=26;
	public const int ID=27;
	public const int IF=28;
	public const int IMPLICS=29;
	public const int IN=30;
	public const int INHERITS=31;
	public const int ISVOID=32;
	public const int L=33;
	public const int LEQ=34;
	public const int LET=35;
	public const int LOOP=36;
	public const int LOWERCASE=37;
	public const int MINUS=38;
	public const int MULT=39;
	public const int NANARITA=40;
	public const int NEW=41;
	public const int NL=42;
	public const int NOT=43;
	public const int NUMBER=44;
	public const int OCTAL_ESC=45;
	public const int OF=46;
	public const int OP_CORCH=47;
	public const int OP_PARENT=48;
	public const int PLUS=49;
	public const int PNT=50;
	public const int POOL=51;
	public const int STRING=52;
	public const int THEN=53;
	public const int TYPE=54;
	public const int UNICODE_ESC=55;
	public const int UPERCASE=56;
	public const int WHILE=57;
	public const int WS=58;

	public COOLParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public COOLParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return COOLParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:8:9: public program : ( class )+ EOF ;
	[GrammarRule("program")]
	public void program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(8, 30);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:8:16: ( ( class )+ EOF )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:8:18: ( class )+ EOF
			{
			DebugLocation(8, 18);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:8:18: ( class )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==CLASS))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:8:19: class
					{
					DebugLocation(8, 19);
					PushFollow(Follow._class_in_program29);
					@class();
					PopFollow();


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(8, 27);
			Match(input,EOF,Follow._EOF_in_program33); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(8, 30);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return;

	}
	// $ANTLR end "program"

	partial void EnterRule_class();
	partial void LeaveRule_class();

	// $ANTLR start "class"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:10:2: class : CLASS WS TYPE WS ( INHERITS )? WS TYPE WS OP_CORCH ( wsnl feature_list )? ( wsnl )? CL_CORCH END wsnl ;
	[GrammarRule("class")]
	private void @class()
	{
		EnterRule_class();
		EnterRule("class", 2);
		TraceIn("class", 2);
		try { DebugEnterRule(GrammarFileName, "class");
		DebugLocation(10, 2);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:10:7: ( CLASS WS TYPE WS ( INHERITS )? WS TYPE WS OP_CORCH ( wsnl feature_list )? ( wsnl )? CL_CORCH END wsnl )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:10:9: CLASS WS TYPE WS ( INHERITS )? WS TYPE WS OP_CORCH ( wsnl feature_list )? ( wsnl )? CL_CORCH END wsnl
			{
			DebugLocation(10, 9);
			Match(input,CLASS,Follow._CLASS_in_class42); 
			DebugLocation(10, 15);
			Match(input,WS,Follow._WS_in_class44); 
			DebugLocation(10, 18);
			Match(input,TYPE,Follow._TYPE_in_class46); 
			DebugLocation(10, 23);
			Match(input,WS,Follow._WS_in_class48); 
			DebugLocation(10, 26);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:10:26: ( INHERITS )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==INHERITS))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:10:27: INHERITS
				{
				DebugLocation(10, 27);
				Match(input,INHERITS,Follow._INHERITS_in_class51); 

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(10, 38);
			Match(input,WS,Follow._WS_in_class55); 
			DebugLocation(10, 41);
			Match(input,TYPE,Follow._TYPE_in_class57); 
			DebugLocation(10, 46);
			Match(input,WS,Follow._WS_in_class59); 
			DebugLocation(10, 49);
			Match(input,OP_CORCH,Follow._OP_CORCH_in_class61); 
			DebugLocation(10, 58);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:10:58: ( wsnl feature_list )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			try
			{
				alt3 = dfa3.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:10:59: wsnl feature_list
				{
				DebugLocation(10, 59);
				PushFollow(Follow._wsnl_in_class64);
				wsnl();
				PopFollow();

				DebugLocation(10, 64);
				PushFollow(Follow._feature_list_in_class66);
				feature_list();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(10, 79);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:10:79: ( wsnl )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==NL||LA4_0==WS))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:10:79: wsnl
				{
				DebugLocation(10, 79);
				PushFollow(Follow._wsnl_in_class70);
				wsnl();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(10, 85);
			Match(input,CL_CORCH,Follow._CL_CORCH_in_class73); 
			DebugLocation(10, 94);
			Match(input,END,Follow._END_in_class75); 
			DebugLocation(10, 98);
			PushFollow(Follow._wsnl_in_class77);
			wsnl();
			PopFollow();


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("class", 2);
			LeaveRule("class", 2);
			LeaveRule_class();
		}
		DebugLocation(11, 2);
		} finally { DebugExitRule(GrammarFileName, "class"); }
		return;

	}
	// $ANTLR end "class"

	partial void EnterRule_feature_list();
	partial void LeaveRule_feature_list();

	// $ANTLR start "feature_list"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:12:2: feature_list : feature ( wsnl feature )* ;
	[GrammarRule("feature_list")]
	private void feature_list()
	{
		EnterRule_feature_list();
		EnterRule("feature_list", 3);
		TraceIn("feature_list", 3);
		try { DebugEnterRule(GrammarFileName, "feature_list");
		DebugLocation(12, 39);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:12:14: ( feature ( wsnl feature )* )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:12:16: feature ( wsnl feature )*
			{
			DebugLocation(12, 16);
			PushFollow(Follow._feature_in_feature_list87);
			feature();
			PopFollow();

			DebugLocation(12, 24);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:12:24: ( wsnl feature )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				try
				{
					alt5 = dfa5.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:12:25: wsnl feature
					{
					DebugLocation(12, 25);
					PushFollow(Follow._wsnl_in_feature_list90);
					wsnl();
					PopFollow();

					DebugLocation(12, 30);
					PushFollow(Follow._feature_in_feature_list92);
					feature();
					PopFollow();


					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("feature_list", 3);
			LeaveRule("feature_list", 3);
			LeaveRule_feature_list();
		}
		DebugLocation(12, 39);
		} finally { DebugExitRule(GrammarFileName, "feature_list"); }
		return;

	}
	// $ANTLR end "feature_list"

	partial void EnterRule_feature();
	partial void LeaveRule_feature();

	// $ANTLR start "feature"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:13:2: feature : ID ( WS )? ( attribute | methodefinition ) END ;
	[GrammarRule("feature")]
	private void feature()
	{
		EnterRule_feature();
		EnterRule("feature", 4);
		TraceIn("feature", 4);
		try { DebugEnterRule(GrammarFileName, "feature");
		DebugLocation(13, 51);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:13:9: ( ID ( WS )? ( attribute | methodefinition ) END )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:13:11: ID ( WS )? ( attribute | methodefinition ) END
			{
			DebugLocation(13, 11);
			Match(input,ID,Follow._ID_in_feature102); 
			DebugLocation(13, 14);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:13:14: ( WS )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0==WS))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:13:15: WS
				{
				DebugLocation(13, 15);
				Match(input,WS,Follow._WS_in_feature105); 

				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(13, 20);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:13:20: ( attribute | methodefinition )
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==DOUBLEP))
			{
				alt7 = 1;
			}
			else if ((LA7_0==OP_PARENT))
			{
				alt7 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:13:21: attribute
				{
				DebugLocation(13, 21);
				PushFollow(Follow._attribute_in_feature110);
				attribute();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:13:31: methodefinition
				{
				DebugLocation(13, 31);
				PushFollow(Follow._methodefinition_in_feature112);
				methodefinition();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(13, 48);
			Match(input,END,Follow._END_in_feature115); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("feature", 4);
			LeaveRule("feature", 4);
			LeaveRule_feature();
		}
		DebugLocation(13, 51);
		} finally { DebugExitRule(GrammarFileName, "feature"); }
		return;

	}
	// $ANTLR end "feature"

	partial void EnterRule_attribute();
	partial void LeaveRule_attribute();

	// $ANTLR start "attribute"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:15:1: attribute : DOUBLEP ( WS )? TYPE ( ( WS )? ASSING ( WS )? expr )? ;
	[GrammarRule("attribute")]
	private void attribute()
	{
		EnterRule_attribute();
		EnterRule("attribute", 5);
		TraceIn("attribute", 5);
		try { DebugEnterRule(GrammarFileName, "attribute");
		DebugLocation(15, 59);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:15:10: ( DOUBLEP ( WS )? TYPE ( ( WS )? ASSING ( WS )? expr )? )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:15:13: DOUBLEP ( WS )? TYPE ( ( WS )? ASSING ( WS )? expr )?
			{
			DebugLocation(15, 13);
			Match(input,DOUBLEP,Follow._DOUBLEP_in_attribute125); 
			DebugLocation(15, 21);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:15:21: ( WS )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==WS))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:15:22: WS
				{
				DebugLocation(15, 22);
				Match(input,WS,Follow._WS_in_attribute128); 

				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(15, 27);
			Match(input,TYPE,Follow._TYPE_in_attribute132); 
			DebugLocation(15, 32);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:15:32: ( ( WS )? ASSING ( WS )? expr )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==ASSING||LA11_0==WS))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:15:33: ( WS )? ASSING ( WS )? expr
				{
				DebugLocation(15, 33);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:15:33: ( WS )?
				int alt9=2;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==WS))
				{
					alt9 = 1;
				}
				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:15:34: WS
					{
					DebugLocation(15, 34);
					Match(input,WS,Follow._WS_in_attribute136); 

					}
					break;

				}
				} finally { DebugExitSubRule(9); }

				DebugLocation(15, 39);
				Match(input,ASSING,Follow._ASSING_in_attribute140); 
				DebugLocation(15, 46);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:15:46: ( WS )?
				int alt10=2;
				try { DebugEnterSubRule(10);
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==WS))
				{
					alt10 = 1;
				}
				} finally { DebugExitDecision(10); }
				switch (alt10)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:15:47: WS
					{
					DebugLocation(15, 47);
					Match(input,WS,Follow._WS_in_attribute143); 

					}
					break;

				}
				} finally { DebugExitSubRule(10); }

				DebugLocation(15, 52);
				PushFollow(Follow._expr_in_attribute147);
				expr();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(11); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("attribute", 5);
			LeaveRule("attribute", 5);
			LeaveRule_attribute();
		}
		DebugLocation(15, 59);
		} finally { DebugExitRule(GrammarFileName, "attribute"); }
		return;

	}
	// $ANTLR end "attribute"

	partial void EnterRule_methodefinition();
	partial void LeaveRule_methodefinition();

	// $ANTLR start "methodefinition"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:2: methodefinition : OP_PARENT ( ( WS )? params_list )? ( WS )? CL_PARENT ( WS )? DOUBLEP ( WS )? TYPE ( WS )? OP_CORCH ( wsnl )? expr CL_CORCH ;
	[GrammarRule("methodefinition")]
	private void methodefinition()
	{
		EnterRule_methodefinition();
		EnterRule("methodefinition", 6);
		TraceIn("methodefinition", 6);
		try { DebugEnterRule(GrammarFileName, "methodefinition");
		DebugLocation(17, 128);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:17: ( OP_PARENT ( ( WS )? params_list )? ( WS )? CL_PARENT ( WS )? DOUBLEP ( WS )? TYPE ( WS )? OP_CORCH ( wsnl )? expr CL_CORCH )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:19: OP_PARENT ( ( WS )? params_list )? ( WS )? CL_PARENT ( WS )? DOUBLEP ( WS )? TYPE ( WS )? OP_CORCH ( wsnl )? expr CL_CORCH
			{
			DebugLocation(17, 19);
			Match(input,OP_PARENT,Follow._OP_PARENT_in_methodefinition159); 
			DebugLocation(17, 29);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:29: ( ( WS )? params_list )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_0 = input.LA(1);

			if ((LA13_0==WS))
			{
				int LA13_1 = input.LA(2);

				if ((LA13_1==ID))
				{
					alt13 = 1;
				}
			}
			else if ((LA13_0==ID))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:30: ( WS )? params_list
				{
				DebugLocation(17, 30);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:30: ( WS )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==WS))
				{
					alt12 = 1;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:31: WS
					{
					DebugLocation(17, 31);
					Match(input,WS,Follow._WS_in_methodefinition163); 

					}
					break;

				}
				} finally { DebugExitSubRule(12); }

				DebugLocation(17, 36);
				PushFollow(Follow._params_list_in_methodefinition167);
				params_list();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(17, 50);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:50: ( WS )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_0 = input.LA(1);

			if ((LA14_0==WS))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:51: WS
				{
				DebugLocation(17, 51);
				Match(input,WS,Follow._WS_in_methodefinition172); 

				}
				break;

			}
			} finally { DebugExitSubRule(14); }

			DebugLocation(17, 56);
			Match(input,CL_PARENT,Follow._CL_PARENT_in_methodefinition176); 
			DebugLocation(17, 66);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:66: ( WS )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_0 = input.LA(1);

			if ((LA15_0==WS))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:67: WS
				{
				DebugLocation(17, 67);
				Match(input,WS,Follow._WS_in_methodefinition179); 

				}
				break;

			}
			} finally { DebugExitSubRule(15); }

			DebugLocation(17, 72);
			Match(input,DOUBLEP,Follow._DOUBLEP_in_methodefinition183); 
			DebugLocation(17, 80);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:80: ( WS )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_0 = input.LA(1);

			if ((LA16_0==WS))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:81: WS
				{
				DebugLocation(17, 81);
				Match(input,WS,Follow._WS_in_methodefinition186); 

				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(17, 86);
			Match(input,TYPE,Follow._TYPE_in_methodefinition190); 
			DebugLocation(17, 91);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:91: ( WS )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_0 = input.LA(1);

			if ((LA17_0==WS))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:92: WS
				{
				DebugLocation(17, 92);
				Match(input,WS,Follow._WS_in_methodefinition193); 

				}
				break;

			}
			} finally { DebugExitSubRule(17); }

			DebugLocation(17, 97);
			Match(input,OP_CORCH,Follow._OP_CORCH_in_methodefinition197); 
			DebugLocation(17, 106);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:106: ( wsnl )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_0 = input.LA(1);

			if ((LA18_0==NL||LA18_0==WS))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:17:107: wsnl
				{
				DebugLocation(17, 107);
				PushFollow(Follow._wsnl_in_methodefinition200);
				wsnl();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(17, 114);
			PushFollow(Follow._expr_in_methodefinition204);
			expr();
			PopFollow();

			DebugLocation(17, 120);
			Match(input,CL_CORCH,Follow._CL_CORCH_in_methodefinition207); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("methodefinition", 6);
			LeaveRule("methodefinition", 6);
			LeaveRule_methodefinition();
		}
		DebugLocation(17, 128);
		} finally { DebugExitRule(GrammarFileName, "methodefinition"); }
		return;

	}
	// $ANTLR end "methodefinition"

	partial void EnterRule_params_list();
	partial void LeaveRule_params_list();

	// $ANTLR start "params_list"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:18:2: params_list : param ( ( WS )? COMA ( WS )? param )* ;
	[GrammarRule("params_list")]
	private void params_list()
	{
		EnterRule_params_list();
		EnterRule("params_list", 7);
		TraceIn("params_list", 7);
		try { DebugEnterRule(GrammarFileName, "params_list");
		DebugLocation(18, 45);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:18:13: ( param ( ( WS )? COMA ( WS )? param )* )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:18:15: param ( ( WS )? COMA ( WS )? param )*
			{
			DebugLocation(18, 15);
			PushFollow(Follow._param_in_params_list215);
			param();
			PopFollow();

			DebugLocation(18, 21);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:18:21: ( ( WS )? COMA ( WS )? param )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==WS))
				{
					int LA21_1 = input.LA(2);

					if ((LA21_1==COMA))
					{
						alt21 = 1;
					}


				}
				else if ((LA21_0==COMA))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:18:22: ( WS )? COMA ( WS )? param
					{
					DebugLocation(18, 22);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:18:22: ( WS )?
					int alt19=2;
					try { DebugEnterSubRule(19);
					try { DebugEnterDecision(19, false);
					int LA19_0 = input.LA(1);

					if ((LA19_0==WS))
					{
						alt19 = 1;
					}
					} finally { DebugExitDecision(19); }
					switch (alt19)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:18:23: WS
						{
						DebugLocation(18, 23);
						Match(input,WS,Follow._WS_in_params_list219); 

						}
						break;

					}
					} finally { DebugExitSubRule(19); }

					DebugLocation(18, 28);
					Match(input,COMA,Follow._COMA_in_params_list223); 
					DebugLocation(18, 33);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:18:33: ( WS )?
					int alt20=2;
					try { DebugEnterSubRule(20);
					try { DebugEnterDecision(20, false);
					int LA20_0 = input.LA(1);

					if ((LA20_0==WS))
					{
						alt20 = 1;
					}
					} finally { DebugExitDecision(20); }
					switch (alt20)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:18:34: WS
						{
						DebugLocation(18, 34);
						Match(input,WS,Follow._WS_in_params_list226); 

						}
						break;

					}
					} finally { DebugExitSubRule(20); }

					DebugLocation(18, 39);
					PushFollow(Follow._param_in_params_list230);
					param();
					PopFollow();


					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("params_list", 7);
			LeaveRule("params_list", 7);
			LeaveRule_params_list();
		}
		DebugLocation(18, 45);
		} finally { DebugExitRule(GrammarFileName, "params_list"); }
		return;

	}
	// $ANTLR end "params_list"

	partial void EnterRule_param();
	partial void LeaveRule_param();

	// $ANTLR start "param"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:19:2: param : ID ( WS )? DOUBLEP ( WS )? TYPE ;
	[GrammarRule("param")]
	private void param()
	{
		EnterRule_param();
		EnterRule("param", 8);
		TraceIn("param", 8);
		try { DebugEnterRule(GrammarFileName, "param");
		DebugLocation(19, 35);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:19:7: ( ID ( WS )? DOUBLEP ( WS )? TYPE )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:19:9: ID ( WS )? DOUBLEP ( WS )? TYPE
			{
			DebugLocation(19, 9);
			Match(input,ID,Follow._ID_in_param239); 
			DebugLocation(19, 12);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:19:12: ( WS )?
			int alt22=2;
			try { DebugEnterSubRule(22);
			try { DebugEnterDecision(22, false);
			int LA22_0 = input.LA(1);

			if ((LA22_0==WS))
			{
				alt22 = 1;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:19:13: WS
				{
				DebugLocation(19, 13);
				Match(input,WS,Follow._WS_in_param242); 

				}
				break;

			}
			} finally { DebugExitSubRule(22); }

			DebugLocation(19, 18);
			Match(input,DOUBLEP,Follow._DOUBLEP_in_param246); 
			DebugLocation(19, 26);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:19:26: ( WS )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_0 = input.LA(1);

			if ((LA23_0==WS))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:19:27: WS
				{
				DebugLocation(19, 27);
				Match(input,WS,Follow._WS_in_param249); 

				}
				break;

			}
			} finally { DebugExitSubRule(23); }

			DebugLocation(19, 32);
			Match(input,TYPE,Follow._TYPE_in_param253); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("param", 8);
			LeaveRule("param", 8);
			LeaveRule_param();
		}
		DebugLocation(19, 35);
		} finally { DebugExitRule(GrammarFileName, "param"); }
		return;

	}
	// $ANTLR end "param"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:21:2: expr : ( assignment | conditionals | loops | blocks | let | case | new | operations );
	[GrammarRule("expr")]
	private void expr()
	{
		EnterRule_expr();
		EnterRule("expr", 9);
		TraceIn("expr", 9);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(21, 15);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:21:6: ( assignment | conditionals | loops | blocks | let | case | new | operations )
			int alt24=8;
			try { DebugEnterDecision(24, false);
			switch (input.LA(1))
			{
			case ID:
				{
				switch (input.LA(2))
				{
				case WS:
					{
					int LA24_9 = input.LA(3);

					if ((LA24_9==COMA||LA24_9==ESAC||LA24_9==FI||LA24_9==ID||LA24_9==IN||LA24_9==LEQ||LA24_9==LOOP||LA24_9==MULT||LA24_9==NL||LA24_9==OF||LA24_9==PLUS||LA24_9==POOL||LA24_9==THEN||LA24_9==WS))
					{
						alt24 = 8;
					}
					else if ((LA24_9==ASSING))
					{
						alt24 = 1;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 24, 9, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case ASSING:
					{
					alt24 = 1;
					}
					break;
				case ARROBA:
				case CL_CORCH:
				case CL_PARENT:
				case COMA:
				case DIV:
				case END:
				case EQ:
				case G:
				case GEQ:
				case ID:
				case ISVOID:
				case L:
				case LEQ:
				case MINUS:
				case MULT:
				case NANARITA:
				case NL:
				case OP_PARENT:
				case PLUS:
				case PNT:
					{
					alt24 = 8;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 24, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case IF:
				{
				alt24 = 2;
				}
				break;
			case WHILE:
				{
				alt24 = 3;
				}
				break;
			case OP_CORCH:
				{
				alt24 = 4;
				}
				break;
			case LET:
				{
				alt24 = 5;
				}
				break;
			case CASE:
				{
				alt24 = 6;
				}
				break;
			case NEW:
				{
				alt24 = 7;
				}
				break;
			case ISVOID:
			case NANARITA:
			case NOT:
			case OP_PARENT:
				{
				alt24 = 8;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:21:8: assignment
				{
				DebugLocation(21, 8);
				PushFollow(Follow._assignment_in_expr261);
				assignment();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:22:6: conditionals
				{
				DebugLocation(22, 6);
				PushFollow(Follow._conditionals_in_expr268);
				conditionals();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:23:6: loops
				{
				DebugLocation(23, 6);
				PushFollow(Follow._loops_in_expr275);
				loops();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:24:6: blocks
				{
				DebugLocation(24, 6);
				PushFollow(Follow._blocks_in_expr282);
				blocks();
				PopFollow();


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:25:6: let
				{
				DebugLocation(25, 6);
				PushFollow(Follow._let_in_expr289);
				let();
				PopFollow();


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:26:6: case
				{
				DebugLocation(26, 6);
				PushFollow(Follow._case_in_expr296);
				@case();
				PopFollow();


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:27:6: new
				{
				DebugLocation(27, 6);
				PushFollow(Follow._new_in_expr303);
				@new();
				PopFollow();


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:28:6: operations
				{
				DebugLocation(28, 6);
				PushFollow(Follow._operations_in_expr310);
				operations();
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expr", 9);
			LeaveRule("expr", 9);
			LeaveRule_expr();
		}
		DebugLocation(28, 15);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return;

	}
	// $ANTLR end "expr"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();

	// $ANTLR start "constant"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:32:2: constant : ( STRING | NUMBER | BOOLEAN );
	[GrammarRule("constant")]
	private void constant()
	{
		EnterRule_constant();
		EnterRule("constant", 10);
		TraceIn("constant", 10);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(32, 32);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:32:10: ( STRING | NUMBER | BOOLEAN )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:
			{
			DebugLocation(32, 10);
			if (input.LA(1)==BOOLEAN||input.LA(1)==NUMBER||input.LA(1)==STRING)
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("constant", 10);
			LeaveRule("constant", 10);
			LeaveRule_constant();
		}
		DebugLocation(32, 32);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return;

	}
	// $ANTLR end "constant"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();

	// $ANTLR start "assignment"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:33:2: assignment : ID ( WS )? ASSING ( WS )? expr ;
	[GrammarRule("assignment")]
	private void assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 11);
		TraceIn("assignment", 11);
		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(33, 40);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:33:12: ( ID ( WS )? ASSING ( WS )? expr )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:33:14: ID ( WS )? ASSING ( WS )? expr
			{
			DebugLocation(33, 14);
			Match(input,ID,Follow._ID_in_assignment337); 
			DebugLocation(33, 17);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:33:17: ( WS )?
			int alt25=2;
			try { DebugEnterSubRule(25);
			try { DebugEnterDecision(25, false);
			int LA25_0 = input.LA(1);

			if ((LA25_0==WS))
			{
				alt25 = 1;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:33:18: WS
				{
				DebugLocation(33, 18);
				Match(input,WS,Follow._WS_in_assignment340); 

				}
				break;

			}
			} finally { DebugExitSubRule(25); }

			DebugLocation(33, 23);
			Match(input,ASSING,Follow._ASSING_in_assignment344); 
			DebugLocation(33, 30);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:33:30: ( WS )?
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if ((LA26_0==WS))
			{
				alt26 = 1;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:33:31: WS
				{
				DebugLocation(33, 31);
				Match(input,WS,Follow._WS_in_assignment347); 

				}
				break;

			}
			} finally { DebugExitSubRule(26); }

			DebugLocation(33, 36);
			PushFollow(Follow._expr_in_assignment351);
			expr();
			PopFollow();


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assignment", 11);
			LeaveRule("assignment", 11);
			LeaveRule_assignment();
		}
		DebugLocation(33, 40);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return;

	}
	// $ANTLR end "assignment"

	partial void EnterRule_conditionals();
	partial void LeaveRule_conditionals();

	// $ANTLR start "conditionals"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:34:2: conditionals : IF WS expr wsnl THEN wsnl expr wsnl FI ;
	[GrammarRule("conditionals")]
	private void conditionals()
	{
		EnterRule_conditionals();
		EnterRule("conditionals", 12);
		TraceIn("conditionals", 12);
		try { DebugEnterRule(GrammarFileName, "conditionals");
		DebugLocation(34, 54);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:34:14: ( IF WS expr wsnl THEN wsnl expr wsnl FI )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:34:16: IF WS expr wsnl THEN wsnl expr wsnl FI
			{
			DebugLocation(34, 16);
			Match(input,IF,Follow._IF_in_conditionals359); 
			DebugLocation(34, 19);
			Match(input,WS,Follow._WS_in_conditionals361); 
			DebugLocation(34, 22);
			PushFollow(Follow._expr_in_conditionals363);
			expr();
			PopFollow();

			DebugLocation(34, 27);
			PushFollow(Follow._wsnl_in_conditionals365);
			wsnl();
			PopFollow();

			DebugLocation(34, 32);
			Match(input,THEN,Follow._THEN_in_conditionals367); 
			DebugLocation(34, 37);
			PushFollow(Follow._wsnl_in_conditionals369);
			wsnl();
			PopFollow();

			DebugLocation(34, 42);
			PushFollow(Follow._expr_in_conditionals371);
			expr();
			PopFollow();

			DebugLocation(34, 47);
			PushFollow(Follow._wsnl_in_conditionals373);
			wsnl();
			PopFollow();

			DebugLocation(34, 52);
			Match(input,FI,Follow._FI_in_conditionals375); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("conditionals", 12);
			LeaveRule("conditionals", 12);
			LeaveRule_conditionals();
		}
		DebugLocation(34, 54);
		} finally { DebugExitRule(GrammarFileName, "conditionals"); }
		return;

	}
	// $ANTLR end "conditionals"

	partial void EnterRule_loops();
	partial void LeaveRule_loops();

	// $ANTLR start "loops"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:35:2: loops : WHILE WS expr wsnl LOOP wsnl expr wsnl POOL ;
	[GrammarRule("loops")]
	private void loops()
	{
		EnterRule_loops();
		EnterRule("loops", 13);
		TraceIn("loops", 13);
		try { DebugEnterRule(GrammarFileName, "loops");
		DebugLocation(35, 52);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:35:7: ( WHILE WS expr wsnl LOOP wsnl expr wsnl POOL )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:35:9: WHILE WS expr wsnl LOOP wsnl expr wsnl POOL
			{
			DebugLocation(35, 9);
			Match(input,WHILE,Follow._WHILE_in_loops383); 
			DebugLocation(35, 15);
			Match(input,WS,Follow._WS_in_loops385); 
			DebugLocation(35, 18);
			PushFollow(Follow._expr_in_loops387);
			expr();
			PopFollow();

			DebugLocation(35, 23);
			PushFollow(Follow._wsnl_in_loops389);
			wsnl();
			PopFollow();

			DebugLocation(35, 28);
			Match(input,LOOP,Follow._LOOP_in_loops391); 
			DebugLocation(35, 33);
			PushFollow(Follow._wsnl_in_loops393);
			wsnl();
			PopFollow();

			DebugLocation(35, 38);
			PushFollow(Follow._expr_in_loops395);
			expr();
			PopFollow();

			DebugLocation(35, 43);
			PushFollow(Follow._wsnl_in_loops397);
			wsnl();
			PopFollow();

			DebugLocation(35, 48);
			Match(input,POOL,Follow._POOL_in_loops399); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("loops", 13);
			LeaveRule("loops", 13);
			LeaveRule_loops();
		}
		DebugLocation(35, 52);
		} finally { DebugExitRule(GrammarFileName, "loops"); }
		return;

	}
	// $ANTLR end "loops"

	partial void EnterRule_blocks();
	partial void LeaveRule_blocks();

	// $ANTLR start "blocks"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:36:2: blocks : OP_CORCH ( ( wsnl )? expr END ( ( wsnl )? expr END )* )? ( wsnl )? CL_CORCH ;
	[GrammarRule("blocks")]
	private void blocks()
	{
		EnterRule_blocks();
		EnterRule("blocks", 14);
		TraceIn("blocks", 14);
		try { DebugEnterRule(GrammarFileName, "blocks");
		DebugLocation(36, 73);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:36:8: ( OP_CORCH ( ( wsnl )? expr END ( ( wsnl )? expr END )* )? ( wsnl )? CL_CORCH )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:36:10: OP_CORCH ( ( wsnl )? expr END ( ( wsnl )? expr END )* )? ( wsnl )? CL_CORCH
			{
			DebugLocation(36, 10);
			Match(input,OP_CORCH,Follow._OP_CORCH_in_blocks407); 
			DebugLocation(36, 19);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:36:19: ( ( wsnl )? expr END ( ( wsnl )? expr END )* )?
			int alt30=2;
			try { DebugEnterSubRule(30);
			try { DebugEnterDecision(30, false);
			try
			{
				alt30 = dfa30.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:36:20: ( wsnl )? expr END ( ( wsnl )? expr END )*
				{
				DebugLocation(36, 20);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:36:20: ( wsnl )?
				int alt27=2;
				try { DebugEnterSubRule(27);
				try { DebugEnterDecision(27, false);
				int LA27_0 = input.LA(1);

				if ((LA27_0==NL||LA27_0==WS))
				{
					alt27 = 1;
				}
				} finally { DebugExitDecision(27); }
				switch (alt27)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:36:21: wsnl
					{
					DebugLocation(36, 21);
					PushFollow(Follow._wsnl_in_blocks411);
					wsnl();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(27); }

				DebugLocation(36, 28);
				PushFollow(Follow._expr_in_blocks415);
				expr();
				PopFollow();

				DebugLocation(36, 33);
				Match(input,END,Follow._END_in_blocks417); 
				DebugLocation(36, 37);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:36:37: ( ( wsnl )? expr END )*
				try { DebugEnterSubRule(29);
				while (true)
				{
					int alt29=2;
					try { DebugEnterDecision(29, false);
					try
					{
						alt29 = dfa29.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(29); }
					switch ( alt29 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:36:38: ( wsnl )? expr END
						{
						DebugLocation(36, 38);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:36:38: ( wsnl )?
						int alt28=2;
						try { DebugEnterSubRule(28);
						try { DebugEnterDecision(28, false);
						int LA28_0 = input.LA(1);

						if ((LA28_0==NL||LA28_0==WS))
						{
							alt28 = 1;
						}
						} finally { DebugExitDecision(28); }
						switch (alt28)
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:36:38: wsnl
							{
							DebugLocation(36, 38);
							PushFollow(Follow._wsnl_in_blocks420);
							wsnl();
							PopFollow();


							}
							break;

						}
						} finally { DebugExitSubRule(28); }

						DebugLocation(36, 44);
						PushFollow(Follow._expr_in_blocks423);
						expr();
						PopFollow();

						DebugLocation(36, 49);
						Match(input,END,Follow._END_in_blocks425); 

						}
						break;

					default:
						goto loop29;
					}
				}

				loop29:
					;

				} finally { DebugExitSubRule(29); }


				}
				break;

			}
			} finally { DebugExitSubRule(30); }

			DebugLocation(36, 57);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:36:57: ( wsnl )?
			int alt31=2;
			try { DebugEnterSubRule(31);
			try { DebugEnterDecision(31, false);
			int LA31_0 = input.LA(1);

			if ((LA31_0==NL||LA31_0==WS))
			{
				alt31 = 1;
			}
			} finally { DebugExitDecision(31); }
			switch (alt31)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:36:58: wsnl
				{
				DebugLocation(36, 58);
				PushFollow(Follow._wsnl_in_blocks432);
				wsnl();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(31); }

			DebugLocation(36, 65);
			Match(input,CL_CORCH,Follow._CL_CORCH_in_blocks436); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("blocks", 14);
			LeaveRule("blocks", 14);
			LeaveRule_blocks();
		}
		DebugLocation(36, 73);
		} finally { DebugExitRule(GrammarFileName, "blocks"); }
		return;

	}
	// $ANTLR end "blocks"

	partial void EnterRule_let();
	partial void LeaveRule_let();

	// $ANTLR start "let"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:37:2: let : LET WS assignment ( ( WS )? COMA ( WS )? assignment )* wsnl IN wsnl expr ;
	[GrammarRule("let")]
	private void let()
	{
		EnterRule_let();
		EnterRule("let", 15);
		TraceIn("let", 15);
		try { DebugEnterRule(GrammarFileName, "let");
		DebugLocation(37, 74);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:37:5: ( LET WS assignment ( ( WS )? COMA ( WS )? assignment )* wsnl IN wsnl expr )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:37:7: LET WS assignment ( ( WS )? COMA ( WS )? assignment )* wsnl IN wsnl expr
			{
			DebugLocation(37, 7);
			Match(input,LET,Follow._LET_in_let444); 
			DebugLocation(37, 11);
			Match(input,WS,Follow._WS_in_let446); 
			DebugLocation(37, 14);
			PushFollow(Follow._assignment_in_let448);
			assignment();
			PopFollow();

			DebugLocation(37, 25);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:37:25: ( ( WS )? COMA ( WS )? assignment )*
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=2;
				try { DebugEnterDecision(34, false);
				int LA34_0 = input.LA(1);

				if ((LA34_0==WS))
				{
					int LA34_1 = input.LA(2);

					if ((LA34_1==COMA))
					{
						alt34 = 1;
					}


				}
				else if ((LA34_0==COMA))
				{
					alt34 = 1;
				}


				} finally { DebugExitDecision(34); }
				switch ( alt34 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:37:27: ( WS )? COMA ( WS )? assignment
					{
					DebugLocation(37, 27);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:37:27: ( WS )?
					int alt32=2;
					try { DebugEnterSubRule(32);
					try { DebugEnterDecision(32, false);
					int LA32_0 = input.LA(1);

					if ((LA32_0==WS))
					{
						alt32 = 1;
					}
					} finally { DebugExitDecision(32); }
					switch (alt32)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:37:28: WS
						{
						DebugLocation(37, 28);
						Match(input,WS,Follow._WS_in_let453); 

						}
						break;

					}
					} finally { DebugExitSubRule(32); }

					DebugLocation(37, 33);
					Match(input,COMA,Follow._COMA_in_let457); 
					DebugLocation(37, 38);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:37:38: ( WS )?
					int alt33=2;
					try { DebugEnterSubRule(33);
					try { DebugEnterDecision(33, false);
					int LA33_0 = input.LA(1);

					if ((LA33_0==WS))
					{
						alt33 = 1;
					}
					} finally { DebugExitDecision(33); }
					switch (alt33)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:37:39: WS
						{
						DebugLocation(37, 39);
						Match(input,WS,Follow._WS_in_let460); 

						}
						break;

					}
					} finally { DebugExitSubRule(33); }

					DebugLocation(37, 44);
					PushFollow(Follow._assignment_in_let464);
					assignment();
					PopFollow();


					}
					break;

				default:
					goto loop34;
				}
			}

			loop34:
				;

			} finally { DebugExitSubRule(34); }

			DebugLocation(37, 57);
			PushFollow(Follow._wsnl_in_let468);
			wsnl();
			PopFollow();

			DebugLocation(37, 62);
			Match(input,IN,Follow._IN_in_let470); 
			DebugLocation(37, 65);
			PushFollow(Follow._wsnl_in_let472);
			wsnl();
			PopFollow();

			DebugLocation(37, 70);
			PushFollow(Follow._expr_in_let474);
			expr();
			PopFollow();


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("let", 15);
			LeaveRule("let", 15);
			LeaveRule_let();
		}
		DebugLocation(37, 74);
		} finally { DebugExitRule(GrammarFileName, "let"); }
		return;

	}
	// $ANTLR end "let"

	partial void EnterRule_case();
	partial void LeaveRule_case();

	// $ANTLR start "case"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:38:2: case : CASE WS expr WS OF ( wsnl param WS IMPLICS wsnl expr )+ wsnl ESAC ;
	[GrammarRule("case")]
	private void @case()
	{
		EnterRule_case();
		EnterRule("case", 16);
		TraceIn("case", 16);
		try { DebugEnterRule(GrammarFileName, "case");
		DebugLocation(38, 71);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:38:6: ( CASE WS expr WS OF ( wsnl param WS IMPLICS wsnl expr )+ wsnl ESAC )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:38:8: CASE WS expr WS OF ( wsnl param WS IMPLICS wsnl expr )+ wsnl ESAC
			{
			DebugLocation(38, 8);
			Match(input,CASE,Follow._CASE_in_case482); 
			DebugLocation(38, 13);
			Match(input,WS,Follow._WS_in_case484); 
			DebugLocation(38, 16);
			PushFollow(Follow._expr_in_case486);
			expr();
			PopFollow();

			DebugLocation(38, 21);
			Match(input,WS,Follow._WS_in_case488); 
			DebugLocation(38, 24);
			Match(input,OF,Follow._OF_in_case490); 
			DebugLocation(38, 27);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:38:27: ( wsnl param WS IMPLICS wsnl expr )+
			int cnt35=0;
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=2;
				try { DebugEnterDecision(35, false);
				try
				{
					alt35 = dfa35.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(35); }
				switch (alt35)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:38:28: wsnl param WS IMPLICS wsnl expr
					{
					DebugLocation(38, 28);
					PushFollow(Follow._wsnl_in_case493);
					wsnl();
					PopFollow();

					DebugLocation(38, 33);
					PushFollow(Follow._param_in_case495);
					param();
					PopFollow();

					DebugLocation(38, 39);
					Match(input,WS,Follow._WS_in_case497); 
					DebugLocation(38, 42);
					Match(input,IMPLICS,Follow._IMPLICS_in_case499); 
					DebugLocation(38, 50);
					PushFollow(Follow._wsnl_in_case501);
					wsnl();
					PopFollow();

					DebugLocation(38, 55);
					PushFollow(Follow._expr_in_case503);
					expr();
					PopFollow();


					}
					break;

				default:
					if (cnt35 >= 1)
						goto loop35;

					EarlyExitException eee35 = new EarlyExitException( 35, input );
					DebugRecognitionException(eee35);
					throw eee35;
				}
				cnt35++;
			}
			loop35:
				;

			} finally { DebugExitSubRule(35); }

			DebugLocation(38, 62);
			PushFollow(Follow._wsnl_in_case507);
			wsnl();
			PopFollow();

			DebugLocation(38, 67);
			Match(input,ESAC,Follow._ESAC_in_case509); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("case", 16);
			LeaveRule("case", 16);
			LeaveRule_case();
		}
		DebugLocation(38, 71);
		} finally { DebugExitRule(GrammarFileName, "case"); }
		return;

	}
	// $ANTLR end "case"

	partial void EnterRule_new();
	partial void LeaveRule_new();

	// $ANTLR start "new"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:39:2: new : NEW WS TYPE ;
	[GrammarRule("new")]
	private void @new()
	{
		EnterRule_new();
		EnterRule("new", 17);
		TraceIn("new", 17);
		try { DebugEnterRule(GrammarFileName, "new");
		DebugLocation(39, 19);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:39:6: ( NEW WS TYPE )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:39:8: NEW WS TYPE
			{
			DebugLocation(39, 8);
			Match(input,NEW,Follow._NEW_in_new518); 
			DebugLocation(39, 12);
			Match(input,WS,Follow._WS_in_new520); 
			DebugLocation(39, 15);
			Match(input,TYPE,Follow._TYPE_in_new522); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("new", 17);
			LeaveRule("new", 17);
			LeaveRule_new();
		}
		DebugLocation(39, 19);
		} finally { DebugExitRule(GrammarFileName, "new"); }
		return;

	}
	// $ANTLR end "new"

	partial void EnterRule_dispatch();
	partial void LeaveRule_dispatch();

	// $ANTLR start "dispatch"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:2: dispatch : ( ARROBA TYPE | PNT ) ID OP_PARENT ( WS )? ( expr ( ( WS )? COMA ( WS )? expr )* )? CL_PARENT ;
	[GrammarRule("dispatch")]
	private void dispatch()
	{
		EnterRule_dispatch();
		EnterRule("dispatch", 18);
		TraceIn("dispatch", 18);
		try { DebugEnterRule(GrammarFileName, "dispatch");
		DebugLocation(41, 86);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:10: ( ( ARROBA TYPE | PNT ) ID OP_PARENT ( WS )? ( expr ( ( WS )? COMA ( WS )? expr )* )? CL_PARENT )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:12: ( ARROBA TYPE | PNT ) ID OP_PARENT ( WS )? ( expr ( ( WS )? COMA ( WS )? expr )* )? CL_PARENT
			{
			DebugLocation(41, 12);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:12: ( ARROBA TYPE | PNT )
			int alt36=2;
			try { DebugEnterSubRule(36);
			try { DebugEnterDecision(36, false);
			int LA36_0 = input.LA(1);

			if ((LA36_0==ARROBA))
			{
				alt36 = 1;
			}
			else if ((LA36_0==PNT))
			{
				alt36 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 36, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:13: ARROBA TYPE
				{
				DebugLocation(41, 13);
				Match(input,ARROBA,Follow._ARROBA_in_dispatch533); 
				DebugLocation(41, 20);
				Match(input,TYPE,Follow._TYPE_in_dispatch535); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:26: PNT
				{
				DebugLocation(41, 26);
				Match(input,PNT,Follow._PNT_in_dispatch538); 

				}
				break;

			}
			} finally { DebugExitSubRule(36); }

			DebugLocation(41, 31);
			Match(input,ID,Follow._ID_in_dispatch541); 
			DebugLocation(41, 34);
			Match(input,OP_PARENT,Follow._OP_PARENT_in_dispatch543); 
			DebugLocation(41, 44);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:44: ( WS )?
			int alt37=2;
			try { DebugEnterSubRule(37);
			try { DebugEnterDecision(37, false);
			int LA37_0 = input.LA(1);

			if ((LA37_0==WS))
			{
				alt37 = 1;
			}
			} finally { DebugExitDecision(37); }
			switch (alt37)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:44: WS
				{
				DebugLocation(41, 44);
				Match(input,WS,Follow._WS_in_dispatch545); 

				}
				break;

			}
			} finally { DebugExitSubRule(37); }

			DebugLocation(41, 48);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:48: ( expr ( ( WS )? COMA ( WS )? expr )* )?
			int alt41=2;
			try { DebugEnterSubRule(41);
			try { DebugEnterDecision(41, false);
			int LA41_0 = input.LA(1);

			if ((LA41_0==CASE||(LA41_0>=ID && LA41_0<=IF)||LA41_0==ISVOID||LA41_0==LET||(LA41_0>=NANARITA && LA41_0<=NEW)||LA41_0==NOT||(LA41_0>=OP_CORCH && LA41_0<=OP_PARENT)||LA41_0==WHILE))
			{
				alt41 = 1;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:49: expr ( ( WS )? COMA ( WS )? expr )*
				{
				DebugLocation(41, 49);
				PushFollow(Follow._expr_in_dispatch549);
				expr();
				PopFollow();

				DebugLocation(41, 54);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:54: ( ( WS )? COMA ( WS )? expr )*
				try { DebugEnterSubRule(40);
				while (true)
				{
					int alt40=2;
					try { DebugEnterDecision(40, false);
					int LA40_0 = input.LA(1);

					if ((LA40_0==COMA||LA40_0==WS))
					{
						alt40 = 1;
					}


					} finally { DebugExitDecision(40); }
					switch ( alt40 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:55: ( WS )? COMA ( WS )? expr
						{
						DebugLocation(41, 55);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:55: ( WS )?
						int alt38=2;
						try { DebugEnterSubRule(38);
						try { DebugEnterDecision(38, false);
						int LA38_0 = input.LA(1);

						if ((LA38_0==WS))
						{
							alt38 = 1;
						}
						} finally { DebugExitDecision(38); }
						switch (alt38)
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:55: WS
							{
							DebugLocation(41, 55);
							Match(input,WS,Follow._WS_in_dispatch552); 

							}
							break;

						}
						} finally { DebugExitSubRule(38); }

						DebugLocation(41, 59);
						Match(input,COMA,Follow._COMA_in_dispatch555); 
						DebugLocation(41, 64);
						// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:64: ( WS )?
						int alt39=2;
						try { DebugEnterSubRule(39);
						try { DebugEnterDecision(39, false);
						int LA39_0 = input.LA(1);

						if ((LA39_0==WS))
						{
							alt39 = 1;
						}
						} finally { DebugExitDecision(39); }
						switch (alt39)
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:41:64: WS
							{
							DebugLocation(41, 64);
							Match(input,WS,Follow._WS_in_dispatch557); 

							}
							break;

						}
						} finally { DebugExitSubRule(39); }

						DebugLocation(41, 68);
						PushFollow(Follow._expr_in_dispatch560);
						expr();
						PopFollow();


						}
						break;

					default:
						goto loop40;
					}
				}

				loop40:
					;

				} finally { DebugExitSubRule(40); }


				}
				break;

			}
			} finally { DebugExitSubRule(41); }

			DebugLocation(41, 77);
			Match(input,CL_PARENT,Follow._CL_PARENT_in_dispatch566); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("dispatch", 18);
			LeaveRule("dispatch", 18);
			LeaveRule_dispatch();
		}
		DebugLocation(41, 86);
		} finally { DebugExitRule(GrammarFileName, "dispatch"); }
		return;

	}
	// $ANTLR end "dispatch"

	partial void EnterRule_operations();
	partial void LeaveRule_operations();

	// $ANTLR start "operations"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:43:2: operations : ( NOT expr )? lv1 ;
	[GrammarRule("operations")]
	private void operations()
	{
		EnterRule_operations();
		EnterRule("operations", 19);
		TraceIn("operations", 19);
		try { DebugEnterRule(GrammarFileName, "operations");
		DebugLocation(43, 21);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:44:3: ( ( NOT expr )? lv1 )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:44:6: ( NOT expr )? lv1
			{
			DebugLocation(44, 6);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:44:6: ( NOT expr )?
			int alt42=2;
			try { DebugEnterSubRule(42);
			try { DebugEnterDecision(42, false);
			int LA42_0 = input.LA(1);

			if ((LA42_0==NOT))
			{
				alt42 = 1;
			}
			} finally { DebugExitDecision(42); }
			switch (alt42)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:44:7: NOT expr
				{
				DebugLocation(44, 7);
				Match(input,NOT,Follow._NOT_in_operations581); 
				DebugLocation(44, 11);
				PushFollow(Follow._expr_in_operations583);
				expr();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(42); }

			DebugLocation(44, 18);
			PushFollow(Follow._lv1_in_operations587);
			lv1();
			PopFollow();


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("operations", 19);
			LeaveRule("operations", 19);
			LeaveRule_operations();
		}
		DebugLocation(44, 21);
		} finally { DebugExitRule(GrammarFileName, "operations"); }
		return;

	}
	// $ANTLR end "operations"

	partial void EnterRule_lv1();
	partial void LeaveRule_lv1();

	// $ANTLR start "lv1"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:3: lv1 : lv2 ( ( WS )? LEQ ( WS )? lv1 | GEQ ( WS )? lv1 | L ( WS )? lv1 | G ( WS )? lv1 | EQ ( WS )? lv1 )? ;
	[GrammarRule("lv1")]
	private void lv1()
	{
		EnterRule_lv1();
		EnterRule("lv1", 20);
		TraceIn("lv1", 20);
		try { DebugEnterRule(GrammarFileName, "lv1");
		DebugLocation(45, 85);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:6: ( lv2 ( ( WS )? LEQ ( WS )? lv1 | GEQ ( WS )? lv1 | L ( WS )? lv1 | G ( WS )? lv1 | EQ ( WS )? lv1 )? )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:9: lv2 ( ( WS )? LEQ ( WS )? lv1 | GEQ ( WS )? lv1 | L ( WS )? lv1 | G ( WS )? lv1 | EQ ( WS )? lv1 )?
			{
			DebugLocation(45, 9);
			PushFollow(Follow._lv2_in_lv1597);
			lv2();
			PopFollow();

			DebugLocation(45, 13);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:13: ( ( WS )? LEQ ( WS )? lv1 | GEQ ( WS )? lv1 | L ( WS )? lv1 | G ( WS )? lv1 | EQ ( WS )? lv1 )?
			int alt49=6;
			try { DebugEnterSubRule(49);
			try { DebugEnterDecision(49, false);
			switch (input.LA(1))
			{
			case WS:
				{
				int LA49_1 = input.LA(2);

				if ((LA49_1==LEQ))
				{
					alt49 = 1;
				}
				}
				break;
			case LEQ:
				{
				alt49 = 1;
				}
				break;
			case GEQ:
				{
				alt49 = 2;
				}
				break;
			case L:
				{
				alt49 = 3;
				}
				break;
			case G:
				{
				alt49 = 4;
				}
				break;
			case EQ:
				{
				alt49 = 5;
				}
				break;
			}

			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:14: ( WS )? LEQ ( WS )? lv1
				{
				DebugLocation(45, 14);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:14: ( WS )?
				int alt43=2;
				try { DebugEnterSubRule(43);
				try { DebugEnterDecision(43, false);
				int LA43_0 = input.LA(1);

				if ((LA43_0==WS))
				{
					alt43 = 1;
				}
				} finally { DebugExitDecision(43); }
				switch (alt43)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:15: WS
					{
					DebugLocation(45, 15);
					Match(input,WS,Follow._WS_in_lv1601); 

					}
					break;

				}
				} finally { DebugExitSubRule(43); }

				DebugLocation(45, 20);
				Match(input,LEQ,Follow._LEQ_in_lv1605); 
				DebugLocation(45, 24);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:24: ( WS )?
				int alt44=2;
				try { DebugEnterSubRule(44);
				try { DebugEnterDecision(44, false);
				int LA44_0 = input.LA(1);

				if ((LA44_0==WS))
				{
					alt44 = 1;
				}
				} finally { DebugExitDecision(44); }
				switch (alt44)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:25: WS
					{
					DebugLocation(45, 25);
					Match(input,WS,Follow._WS_in_lv1608); 

					}
					break;

				}
				} finally { DebugExitSubRule(44); }

				DebugLocation(45, 30);
				PushFollow(Follow._lv1_in_lv1612);
				lv1();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:34: GEQ ( WS )? lv1
				{
				DebugLocation(45, 34);
				Match(input,GEQ,Follow._GEQ_in_lv1614); 
				DebugLocation(45, 38);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:38: ( WS )?
				int alt45=2;
				try { DebugEnterSubRule(45);
				try { DebugEnterDecision(45, false);
				int LA45_0 = input.LA(1);

				if ((LA45_0==WS))
				{
					alt45 = 1;
				}
				} finally { DebugExitDecision(45); }
				switch (alt45)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:39: WS
					{
					DebugLocation(45, 39);
					Match(input,WS,Follow._WS_in_lv1617); 

					}
					break;

				}
				} finally { DebugExitSubRule(45); }

				DebugLocation(45, 44);
				PushFollow(Follow._lv1_in_lv1621);
				lv1();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:48: L ( WS )? lv1
				{
				DebugLocation(45, 48);
				Match(input,L,Follow._L_in_lv1623); 
				DebugLocation(45, 50);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:50: ( WS )?
				int alt46=2;
				try { DebugEnterSubRule(46);
				try { DebugEnterDecision(46, false);
				int LA46_0 = input.LA(1);

				if ((LA46_0==WS))
				{
					alt46 = 1;
				}
				} finally { DebugExitDecision(46); }
				switch (alt46)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:51: WS
					{
					DebugLocation(45, 51);
					Match(input,WS,Follow._WS_in_lv1626); 

					}
					break;

				}
				} finally { DebugExitSubRule(46); }

				DebugLocation(45, 56);
				PushFollow(Follow._lv1_in_lv1630);
				lv1();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:60: G ( WS )? lv1
				{
				DebugLocation(45, 60);
				Match(input,G,Follow._G_in_lv1632); 
				DebugLocation(45, 62);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:62: ( WS )?
				int alt47=2;
				try { DebugEnterSubRule(47);
				try { DebugEnterDecision(47, false);
				int LA47_0 = input.LA(1);

				if ((LA47_0==WS))
				{
					alt47 = 1;
				}
				} finally { DebugExitDecision(47); }
				switch (alt47)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:63: WS
					{
					DebugLocation(45, 63);
					Match(input,WS,Follow._WS_in_lv1635); 

					}
					break;

				}
				} finally { DebugExitSubRule(47); }

				DebugLocation(45, 68);
				PushFollow(Follow._lv1_in_lv1639);
				lv1();
				PopFollow();


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:72: EQ ( WS )? lv1
				{
				DebugLocation(45, 72);
				Match(input,EQ,Follow._EQ_in_lv1641); 
				DebugLocation(45, 75);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:75: ( WS )?
				int alt48=2;
				try { DebugEnterSubRule(48);
				try { DebugEnterDecision(48, false);
				int LA48_0 = input.LA(1);

				if ((LA48_0==WS))
				{
					alt48 = 1;
				}
				} finally { DebugExitDecision(48); }
				switch (alt48)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:45:76: WS
					{
					DebugLocation(45, 76);
					Match(input,WS,Follow._WS_in_lv1644); 

					}
					break;

				}
				} finally { DebugExitSubRule(48); }

				DebugLocation(45, 81);
				PushFollow(Follow._lv1_in_lv1648);
				lv1();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(49); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("lv1", 20);
			LeaveRule("lv1", 20);
			LeaveRule_lv1();
		}
		DebugLocation(45, 85);
		} finally { DebugExitRule(GrammarFileName, "lv1"); }
		return;

	}
	// $ANTLR end "lv1"

	partial void EnterRule_lv2();
	partial void LeaveRule_lv2();

	// $ANTLR start "lv2"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:46:3: lv2 : lv3 ( ( WS )? PLUS ( WS )? lv2 | MINUS ( WS )? lv2 )? ;
	[GrammarRule("lv2")]
	private void lv2()
	{
		EnterRule_lv2();
		EnterRule("lv2", 21);
		TraceIn("lv2", 21);
		try { DebugEnterRule(GrammarFileName, "lv2");
		DebugLocation(46, 51);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:46:6: ( lv3 ( ( WS )? PLUS ( WS )? lv2 | MINUS ( WS )? lv2 )? )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:46:8: lv3 ( ( WS )? PLUS ( WS )? lv2 | MINUS ( WS )? lv2 )?
			{
			DebugLocation(46, 8);
			PushFollow(Follow._lv3_in_lv2658);
			lv3();
			PopFollow();

			DebugLocation(46, 12);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:46:12: ( ( WS )? PLUS ( WS )? lv2 | MINUS ( WS )? lv2 )?
			int alt53=3;
			try { DebugEnterSubRule(53);
			try { DebugEnterDecision(53, false);
			switch (input.LA(1))
			{
			case WS:
				{
				int LA53_1 = input.LA(2);

				if ((LA53_1==PLUS))
				{
					alt53 = 1;
				}
				}
				break;
			case PLUS:
				{
				alt53 = 1;
				}
				break;
			case MINUS:
				{
				alt53 = 2;
				}
				break;
			}

			} finally { DebugExitDecision(53); }
			switch (alt53)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:46:13: ( WS )? PLUS ( WS )? lv2
				{
				DebugLocation(46, 13);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:46:13: ( WS )?
				int alt50=2;
				try { DebugEnterSubRule(50);
				try { DebugEnterDecision(50, false);
				int LA50_0 = input.LA(1);

				if ((LA50_0==WS))
				{
					alt50 = 1;
				}
				} finally { DebugExitDecision(50); }
				switch (alt50)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:46:14: WS
					{
					DebugLocation(46, 14);
					Match(input,WS,Follow._WS_in_lv2662); 

					}
					break;

				}
				} finally { DebugExitSubRule(50); }

				DebugLocation(46, 19);
				Match(input,PLUS,Follow._PLUS_in_lv2666); 
				DebugLocation(46, 24);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:46:24: ( WS )?
				int alt51=2;
				try { DebugEnterSubRule(51);
				try { DebugEnterDecision(51, false);
				int LA51_0 = input.LA(1);

				if ((LA51_0==WS))
				{
					alt51 = 1;
				}
				} finally { DebugExitDecision(51); }
				switch (alt51)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:46:25: WS
					{
					DebugLocation(46, 25);
					Match(input,WS,Follow._WS_in_lv2669); 

					}
					break;

				}
				} finally { DebugExitSubRule(51); }

				DebugLocation(46, 30);
				PushFollow(Follow._lv2_in_lv2673);
				lv2();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:46:34: MINUS ( WS )? lv2
				{
				DebugLocation(46, 34);
				Match(input,MINUS,Follow._MINUS_in_lv2675); 
				DebugLocation(46, 40);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:46:40: ( WS )?
				int alt52=2;
				try { DebugEnterSubRule(52);
				try { DebugEnterDecision(52, false);
				int LA52_0 = input.LA(1);

				if ((LA52_0==WS))
				{
					alt52 = 1;
				}
				} finally { DebugExitDecision(52); }
				switch (alt52)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:46:41: WS
					{
					DebugLocation(46, 41);
					Match(input,WS,Follow._WS_in_lv2678); 

					}
					break;

				}
				} finally { DebugExitSubRule(52); }

				DebugLocation(46, 46);
				PushFollow(Follow._lv2_in_lv2682);
				lv2();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(53); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("lv2", 21);
			LeaveRule("lv2", 21);
			LeaveRule_lv2();
		}
		DebugLocation(46, 51);
		} finally { DebugExitRule(GrammarFileName, "lv2"); }
		return;

	}
	// $ANTLR end "lv2"

	partial void EnterRule_lv3();
	partial void LeaveRule_lv3();

	// $ANTLR start "lv3"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:3: lv3 : lv4 ( ( WS )? MULT ( WS )? lv3 | DIV ( WS )? lv3 )? ;
	[GrammarRule("lv3")]
	private void lv3()
	{
		EnterRule_lv3();
		EnterRule("lv3", 22);
		TraceIn("lv3", 22);
		try { DebugEnterRule(GrammarFileName, "lv3");
		DebugLocation(47, 47);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:6: ( lv4 ( ( WS )? MULT ( WS )? lv3 | DIV ( WS )? lv3 )? )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:8: lv4 ( ( WS )? MULT ( WS )? lv3 | DIV ( WS )? lv3 )?
			{
			DebugLocation(47, 8);
			PushFollow(Follow._lv4_in_lv3693);
			lv4();
			PopFollow();

			DebugLocation(47, 11);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:11: ( ( WS )? MULT ( WS )? lv3 | DIV ( WS )? lv3 )?
			int alt57=3;
			try { DebugEnterSubRule(57);
			try { DebugEnterDecision(57, false);
			switch (input.LA(1))
			{
			case WS:
				{
				int LA57_1 = input.LA(2);

				if ((LA57_1==MULT))
				{
					alt57 = 1;
				}
				}
				break;
			case MULT:
				{
				alt57 = 1;
				}
				break;
			case DIV:
				{
				alt57 = 2;
				}
				break;
			}

			} finally { DebugExitDecision(57); }
			switch (alt57)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:12: ( WS )? MULT ( WS )? lv3
				{
				DebugLocation(47, 12);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:12: ( WS )?
				int alt54=2;
				try { DebugEnterSubRule(54);
				try { DebugEnterDecision(54, false);
				int LA54_0 = input.LA(1);

				if ((LA54_0==WS))
				{
					alt54 = 1;
				}
				} finally { DebugExitDecision(54); }
				switch (alt54)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:13: WS
					{
					DebugLocation(47, 13);
					Match(input,WS,Follow._WS_in_lv3696); 

					}
					break;

				}
				} finally { DebugExitSubRule(54); }

				DebugLocation(47, 18);
				Match(input,MULT,Follow._MULT_in_lv3700); 
				DebugLocation(47, 23);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:23: ( WS )?
				int alt55=2;
				try { DebugEnterSubRule(55);
				try { DebugEnterDecision(55, false);
				int LA55_0 = input.LA(1);

				if ((LA55_0==WS))
				{
					alt55 = 1;
				}
				} finally { DebugExitDecision(55); }
				switch (alt55)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:24: WS
					{
					DebugLocation(47, 24);
					Match(input,WS,Follow._WS_in_lv3703); 

					}
					break;

				}
				} finally { DebugExitSubRule(55); }

				DebugLocation(47, 29);
				PushFollow(Follow._lv3_in_lv3707);
				lv3();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:33: DIV ( WS )? lv3
				{
				DebugLocation(47, 33);
				Match(input,DIV,Follow._DIV_in_lv3709); 
				DebugLocation(47, 37);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:37: ( WS )?
				int alt56=2;
				try { DebugEnterSubRule(56);
				try { DebugEnterDecision(56, false);
				int LA56_0 = input.LA(1);

				if ((LA56_0==WS))
				{
					alt56 = 1;
				}
				} finally { DebugExitDecision(56); }
				switch (alt56)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:47:38: WS
					{
					DebugLocation(47, 38);
					Match(input,WS,Follow._WS_in_lv3712); 

					}
					break;

				}
				} finally { DebugExitSubRule(56); }

				DebugLocation(47, 43);
				PushFollow(Follow._lv3_in_lv3716);
				lv3();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(57); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("lv3", 22);
			LeaveRule("lv3", 22);
			LeaveRule_lv3();
		}
		DebugLocation(47, 47);
		} finally { DebugExitRule(GrammarFileName, "lv3"); }
		return;

	}
	// $ANTLR end "lv3"

	partial void EnterRule_lv4();
	partial void LeaveRule_lv4();

	// $ANTLR start "lv4"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:3: lv4 : ( ISVOID WS expr )? lv5 ;
	[GrammarRule("lv4")]
	private void lv4()
	{
		EnterRule_lv4();
		EnterRule("lv4", 23);
		TraceIn("lv4", 23);
		try { DebugEnterRule(GrammarFileName, "lv4");
		DebugLocation(48, 28);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:6: ( ( ISVOID WS expr )? lv5 )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:8: ( ISVOID WS expr )? lv5
			{
			DebugLocation(48, 8);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:8: ( ISVOID WS expr )?
			int alt58=2;
			try { DebugEnterSubRule(58);
			try { DebugEnterDecision(58, false);
			int LA58_0 = input.LA(1);

			if ((LA58_0==ISVOID))
			{
				alt58 = 1;
			}
			} finally { DebugExitDecision(58); }
			switch (alt58)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:48:9: ISVOID WS expr
				{
				DebugLocation(48, 9);
				Match(input,ISVOID,Follow._ISVOID_in_lv4727); 
				DebugLocation(48, 16);
				Match(input,WS,Follow._WS_in_lv4729); 
				DebugLocation(48, 19);
				PushFollow(Follow._expr_in_lv4731);
				expr();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(58); }

			DebugLocation(48, 25);
			PushFollow(Follow._lv5_in_lv4734);
			lv5();
			PopFollow();


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("lv4", 23);
			LeaveRule("lv4", 23);
			LeaveRule_lv4();
		}
		DebugLocation(48, 28);
		} finally { DebugExitRule(GrammarFileName, "lv4"); }
		return;

	}
	// $ANTLR end "lv4"

	partial void EnterRule_lv5();
	partial void LeaveRule_lv5();

	// $ANTLR start "lv5"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:49:3: lv5 : ( nanarita )? lv6 ;
	[GrammarRule("lv5")]
	private void lv5()
	{
		EnterRule_lv5();
		EnterRule("lv5", 24);
		TraceIn("lv5", 24);
		try { DebugEnterRule(GrammarFileName, "lv5");
		DebugLocation(49, 21);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:49:6: ( ( nanarita )? lv6 )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:49:8: ( nanarita )? lv6
			{
			DebugLocation(49, 8);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:49:8: ( nanarita )?
			int alt59=2;
			try { DebugEnterSubRule(59);
			try { DebugEnterDecision(59, false);
			int LA59_0 = input.LA(1);

			if ((LA59_0==NANARITA))
			{
				alt59 = 1;
			}
			} finally { DebugExitDecision(59); }
			switch (alt59)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:49:8: nanarita
				{
				DebugLocation(49, 8);
				PushFollow(Follow._nanarita_in_lv5743);
				nanarita();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(59); }

			DebugLocation(49, 18);
			PushFollow(Follow._lv6_in_lv5746);
			lv6();
			PopFollow();


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("lv5", 24);
			LeaveRule("lv5", 24);
			LeaveRule_lv5();
		}
		DebugLocation(49, 21);
		} finally { DebugExitRule(GrammarFileName, "lv5"); }
		return;

	}
	// $ANTLR end "lv5"

	partial void EnterRule_lv6();
	partial void LeaveRule_lv6();

	// $ANTLR start "lv6"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:50:3: lv6 : ( ID | OP_PARENT expr CL_PARENT ) ( dispatch )? ;
	[GrammarRule("lv6")]
	private void lv6()
	{
		EnterRule_lv6();
		EnterRule("lv6", 25);
		TraceIn("lv6", 25);
		try { DebugEnterRule(GrammarFileName, "lv6");
		DebugLocation(50, 48);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:50:6: ( ( ID | OP_PARENT expr CL_PARENT ) ( dispatch )? )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:50:8: ( ID | OP_PARENT expr CL_PARENT ) ( dispatch )?
			{
			DebugLocation(50, 8);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:50:8: ( ID | OP_PARENT expr CL_PARENT )
			int alt60=2;
			try { DebugEnterSubRule(60);
			try { DebugEnterDecision(60, false);
			int LA60_0 = input.LA(1);

			if ((LA60_0==ID))
			{
				alt60 = 1;
			}
			else if ((LA60_0==OP_PARENT))
			{
				alt60 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 60, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:50:9: ID
				{
				DebugLocation(50, 9);
				Match(input,ID,Follow._ID_in_lv6756); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:50:12: OP_PARENT expr CL_PARENT
				{
				DebugLocation(50, 12);
				Match(input,OP_PARENT,Follow._OP_PARENT_in_lv6758); 
				DebugLocation(50, 22);
				PushFollow(Follow._expr_in_lv6760);
				expr();
				PopFollow();

				DebugLocation(50, 27);
				Match(input,CL_PARENT,Follow._CL_PARENT_in_lv6762); 

				}
				break;

			}
			} finally { DebugExitSubRule(60); }

			DebugLocation(50, 37);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:50:37: ( dispatch )?
			int alt61=2;
			try { DebugEnterSubRule(61);
			try { DebugEnterDecision(61, false);
			int LA61_0 = input.LA(1);

			if ((LA61_0==ARROBA||LA61_0==PNT))
			{
				alt61 = 1;
			}
			} finally { DebugExitDecision(61); }
			switch (alt61)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:50:38: dispatch
				{
				DebugLocation(50, 38);
				PushFollow(Follow._dispatch_in_lv6765);
				dispatch();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(61); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("lv6", 25);
			LeaveRule("lv6", 25);
			LeaveRule_lv6();
		}
		DebugLocation(50, 48);
		} finally { DebugExitRule(GrammarFileName, "lv6"); }
		return;

	}
	// $ANTLR end "lv6"

	partial void EnterRule_nanarita();
	partial void LeaveRule_nanarita();

	// $ANTLR start "nanarita"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:52:2: nanarita : NANARITA expr ;
	[GrammarRule("nanarita")]
	private void nanarita()
	{
		EnterRule_nanarita();
		EnterRule("nanarita", 26);
		TraceIn("nanarita", 26);
		try { DebugEnterRule(GrammarFileName, "nanarita");
		DebugLocation(52, 25);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:52:10: ( NANARITA expr )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:52:12: NANARITA expr
			{
			DebugLocation(52, 12);
			Match(input,NANARITA,Follow._NANARITA_in_nanarita778); 
			DebugLocation(52, 21);
			PushFollow(Follow._expr_in_nanarita780);
			expr();
			PopFollow();


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("nanarita", 26);
			LeaveRule("nanarita", 26);
			LeaveRule_nanarita();
		}
		DebugLocation(52, 25);
		} finally { DebugExitRule(GrammarFileName, "nanarita"); }
		return;

	}
	// $ANTLR end "nanarita"

	partial void EnterRule_wsnl();
	partial void LeaveRule_wsnl();

	// $ANTLR start "wsnl"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:53:2: wsnl : ( WS | NL )+ ;
	[GrammarRule("wsnl")]
	private void wsnl()
	{
		EnterRule_wsnl();
		EnterRule("wsnl", 27);
		TraceIn("wsnl", 27);
		try { DebugEnterRule(GrammarFileName, "wsnl");
		DebugLocation(53, 17);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:53:7: ( ( WS | NL )+ )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:53:9: ( WS | NL )+
			{
			DebugLocation(53, 9);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:53:9: ( WS | NL )+
			int cnt62=0;
			try { DebugEnterSubRule(62);
			while (true)
			{
				int alt62=2;
				try { DebugEnterDecision(62, false);
				int LA62_0 = input.LA(1);

				if ((LA62_0==NL||LA62_0==WS))
				{
					alt62 = 1;
				}


				} finally { DebugExitDecision(62); }
				switch (alt62)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:
					{
					DebugLocation(53, 9);
					if (input.LA(1)==NL||input.LA(1)==WS)
					{
						input.Consume();
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}


					}
					break;

				default:
					if (cnt62 >= 1)
						goto loop62;

					EarlyExitException eee62 = new EarlyExitException( 62, input );
					DebugRecognitionException(eee62);
					throw eee62;
				}
				cnt62++;
			}
			loop62:
				;

			} finally { DebugExitSubRule(62); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("wsnl", 27);
			LeaveRule("wsnl", 27);
			LeaveRule_wsnl();
		}
		DebugLocation(53, 17);
		} finally { DebugExitRule(GrammarFileName, "wsnl"); }
		return;

	}
	// $ANTLR end "wsnl"

	partial void EnterRule_compileUnit();
	partial void LeaveRule_compileUnit();

	// $ANTLR start "compileUnit"
	// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:54:1: compileUnit : EOF ;
	[GrammarRule("compileUnit")]
	private void compileUnit()
	{
		EnterRule_compileUnit();
		EnterRule("compileUnit", 28);
		TraceIn("compileUnit", 28);
		try { DebugEnterRule(GrammarFileName, "compileUnit");
		DebugLocation(54, 1);
		try
		{
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:55:2: ( EOF )
			DebugEnterAlt(1);
			// C:\\Users\\Nardo\\Documents\\Visual Studio 2015\\Projects\\COOL\\LexingParsingCOOL\\COOL.g:55:4: EOF
			{
			DebugLocation(55, 4);
			Match(input,EOF,Follow._EOF_in_compileUnit803); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("compileUnit", 28);
			LeaveRule("compileUnit", 28);
			LeaveRule_compileUnit();
		}
		DebugLocation(56, 1);
		} finally { DebugExitRule(GrammarFileName, "compileUnit"); }
		return;

	}
	// $ANTLR end "compileUnit"
	#endregion Rules


	#region DFA
	private DFA3 dfa3;
	private DFA5 dfa5;
	private DFA30 dfa30;
	private DFA29 dfa29;
	private DFA35 dfa35;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa3 = new DFA3( this );
		dfa5 = new DFA5( this );
		dfa30 = new DFA30( this );
		dfa29 = new DFA29( this );
		dfa35 = new DFA35( this );
	}

	private class DFA3 : DFA
	{
		private const string DFA3_eotS =
			"\x4\xFFFF";
		private const string DFA3_eofS =
			"\x4\xFFFF";
		private const string DFA3_minS =
			"\x2\xA\x2\xFFFF";
		private const string DFA3_maxS =
			"\x2\x3A\x2\xFFFF";
		private const string DFA3_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA3_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA3_transitionS =
			{
				"\x1\x2\x1F\xFFFF\x1\x1\xF\xFFFF\x1\x1",
				"\x1\x2\x10\xFFFF\x1\x3\xE\xFFFF\x1\x1\xF\xFFFF\x1\x1",
				"",
				""
			};

		private static readonly short[] DFA3_eot = DFA.UnpackEncodedString(DFA3_eotS);
		private static readonly short[] DFA3_eof = DFA.UnpackEncodedString(DFA3_eofS);
		private static readonly char[] DFA3_min = DFA.UnpackEncodedStringToUnsignedChars(DFA3_minS);
		private static readonly char[] DFA3_max = DFA.UnpackEncodedStringToUnsignedChars(DFA3_maxS);
		private static readonly short[] DFA3_accept = DFA.UnpackEncodedString(DFA3_acceptS);
		private static readonly short[] DFA3_special = DFA.UnpackEncodedString(DFA3_specialS);
		private static readonly short[][] DFA3_transition;

		static DFA3()
		{
			int numStates = DFA3_transitionS.Length;
			DFA3_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA3_transition[i] = DFA.UnpackEncodedString(DFA3_transitionS[i]);
			}
		}

		public DFA3( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 3;
			this.eot = DFA3_eot;
			this.eof = DFA3_eof;
			this.min = DFA3_min;
			this.max = DFA3_max;
			this.accept = DFA3_accept;
			this.special = DFA3_special;
			this.transition = DFA3_transition;
		}

		public override string Description { get { return "10:58: ( wsnl feature_list )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA5 : DFA
	{
		private const string DFA5_eotS =
			"\x4\xFFFF";
		private const string DFA5_eofS =
			"\x4\xFFFF";
		private const string DFA5_minS =
			"\x2\xA\x2\xFFFF";
		private const string DFA5_maxS =
			"\x2\x3A\x2\xFFFF";
		private const string DFA5_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA5_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA5_transitionS =
			{
				"\x1\x2\x1F\xFFFF\x1\x1\xF\xFFFF\x1\x1",
				"\x1\x2\x10\xFFFF\x1\x3\xE\xFFFF\x1\x1\xF\xFFFF\x1\x1",
				"",
				""
			};

		private static readonly short[] DFA5_eot = DFA.UnpackEncodedString(DFA5_eotS);
		private static readonly short[] DFA5_eof = DFA.UnpackEncodedString(DFA5_eofS);
		private static readonly char[] DFA5_min = DFA.UnpackEncodedStringToUnsignedChars(DFA5_minS);
		private static readonly char[] DFA5_max = DFA.UnpackEncodedStringToUnsignedChars(DFA5_maxS);
		private static readonly short[] DFA5_accept = DFA.UnpackEncodedString(DFA5_acceptS);
		private static readonly short[] DFA5_special = DFA.UnpackEncodedString(DFA5_specialS);
		private static readonly short[][] DFA5_transition;

		static DFA5()
		{
			int numStates = DFA5_transitionS.Length;
			DFA5_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA5_transition[i] = DFA.UnpackEncodedString(DFA5_transitionS[i]);
			}
		}

		public DFA5( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 5;
			this.eot = DFA5_eot;
			this.eof = DFA5_eof;
			this.min = DFA5_min;
			this.max = DFA5_max;
			this.accept = DFA5_accept;
			this.special = DFA5_special;
			this.transition = DFA5_transition;
		}

		public override string Description { get { return "()* loopback of 12:24: ( wsnl feature )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA30 : DFA
	{
		private const string DFA30_eotS =
			"\x4\xFFFF";
		private const string DFA30_eofS =
			"\x4\xFFFF";
		private const string DFA30_minS =
			"\x2\x7\x2\xFFFF";
		private const string DFA30_maxS =
			"\x2\x3A\x2\xFFFF";
		private const string DFA30_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA30_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA30_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x3\x10\xFFFF\x2\x2\x3\xFFFF\x1\x2\x2\xFFFF\x1\x2"+
				"\x4\xFFFF\x2\x2\x1\x1\x1\x2\x3\xFFFF\x2\x2\x8\xFFFF\x1\x2\x1\x1",
				"\x1\x2\x2\xFFFF\x1\x3\x10\xFFFF\x2\x2\x3\xFFFF\x1\x2\x2\xFFFF\x1\x2"+
				"\x4\xFFFF\x2\x2\x1\x1\x1\x2\x3\xFFFF\x2\x2\x8\xFFFF\x1\x2\x1\x1",
				"",
				""
			};

		private static readonly short[] DFA30_eot = DFA.UnpackEncodedString(DFA30_eotS);
		private static readonly short[] DFA30_eof = DFA.UnpackEncodedString(DFA30_eofS);
		private static readonly char[] DFA30_min = DFA.UnpackEncodedStringToUnsignedChars(DFA30_minS);
		private static readonly char[] DFA30_max = DFA.UnpackEncodedStringToUnsignedChars(DFA30_maxS);
		private static readonly short[] DFA30_accept = DFA.UnpackEncodedString(DFA30_acceptS);
		private static readonly short[] DFA30_special = DFA.UnpackEncodedString(DFA30_specialS);
		private static readonly short[][] DFA30_transition;

		static DFA30()
		{
			int numStates = DFA30_transitionS.Length;
			DFA30_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA30_transition[i] = DFA.UnpackEncodedString(DFA30_transitionS[i]);
			}
		}

		public DFA30( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 30;
			this.eot = DFA30_eot;
			this.eof = DFA30_eof;
			this.min = DFA30_min;
			this.max = DFA30_max;
			this.accept = DFA30_accept;
			this.special = DFA30_special;
			this.transition = DFA30_transition;
		}

		public override string Description { get { return "36:19: ( ( wsnl )? expr END ( ( wsnl )? expr END )* )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA29 : DFA
	{
		private const string DFA29_eotS =
			"\x4\xFFFF";
		private const string DFA29_eofS =
			"\x4\xFFFF";
		private const string DFA29_minS =
			"\x2\x7\x2\xFFFF";
		private const string DFA29_maxS =
			"\x2\x3A\x2\xFFFF";
		private const string DFA29_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA29_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA29_transitionS =
			{
				"\x1\x3\x2\xFFFF\x1\x2\x10\xFFFF\x2\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1\x3"+
				"\x4\xFFFF\x2\x3\x1\x1\x1\x3\x3\xFFFF\x2\x3\x8\xFFFF\x1\x3\x1\x1",
				"\x1\x3\x2\xFFFF\x1\x2\x10\xFFFF\x2\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1\x3"+
				"\x4\xFFFF\x2\x3\x1\x1\x1\x3\x3\xFFFF\x2\x3\x8\xFFFF\x1\x3\x1\x1",
				"",
				""
			};

		private static readonly short[] DFA29_eot = DFA.UnpackEncodedString(DFA29_eotS);
		private static readonly short[] DFA29_eof = DFA.UnpackEncodedString(DFA29_eofS);
		private static readonly char[] DFA29_min = DFA.UnpackEncodedStringToUnsignedChars(DFA29_minS);
		private static readonly char[] DFA29_max = DFA.UnpackEncodedStringToUnsignedChars(DFA29_maxS);
		private static readonly short[] DFA29_accept = DFA.UnpackEncodedString(DFA29_acceptS);
		private static readonly short[] DFA29_special = DFA.UnpackEncodedString(DFA29_specialS);
		private static readonly short[][] DFA29_transition;

		static DFA29()
		{
			int numStates = DFA29_transitionS.Length;
			DFA29_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA29_transition[i] = DFA.UnpackEncodedString(DFA29_transitionS[i]);
			}
		}

		public DFA29( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 29;
			this.eot = DFA29_eot;
			this.eof = DFA29_eof;
			this.min = DFA29_min;
			this.max = DFA29_max;
			this.accept = DFA29_accept;
			this.special = DFA29_special;
			this.transition = DFA29_transition;
		}

		public override string Description { get { return "()* loopback of 36:37: ( ( wsnl )? expr END )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA35 : DFA
	{
		private const string DFA35_eotS =
			"\x4\xFFFF";
		private const string DFA35_eofS =
			"\x4\xFFFF";
		private const string DFA35_minS =
			"\x1\x2A\x1\x14\x2\xFFFF";
		private const string DFA35_maxS =
			"\x2\x3A\x2\xFFFF";
		private const string DFA35_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA35_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA35_transitionS =
			{
				"\x1\x1\xF\xFFFF\x1\x1",
				"\x1\x2\x6\xFFFF\x1\x3\xE\xFFFF\x1\x1\xF\xFFFF\x1\x1",
				"",
				""
			};

		private static readonly short[] DFA35_eot = DFA.UnpackEncodedString(DFA35_eotS);
		private static readonly short[] DFA35_eof = DFA.UnpackEncodedString(DFA35_eofS);
		private static readonly char[] DFA35_min = DFA.UnpackEncodedStringToUnsignedChars(DFA35_minS);
		private static readonly char[] DFA35_max = DFA.UnpackEncodedStringToUnsignedChars(DFA35_maxS);
		private static readonly short[] DFA35_accept = DFA.UnpackEncodedString(DFA35_acceptS);
		private static readonly short[] DFA35_special = DFA.UnpackEncodedString(DFA35_specialS);
		private static readonly short[][] DFA35_transition;

		static DFA35()
		{
			int numStates = DFA35_transitionS.Length;
			DFA35_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA35_transition[i] = DFA.UnpackEncodedString(DFA35_transitionS[i]);
			}
		}

		public DFA35( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 35;
			this.eot = DFA35_eot;
			this.eof = DFA35_eof;
			this.min = DFA35_min;
			this.max = DFA35_max;
			this.accept = DFA35_accept;
			this.special = DFA35_special;
			this.transition = DFA35_transition;
		}

		public override string Description { get { return "()+ loopback of 38:27: ( wsnl param WS IMPLICS wsnl expr )+"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _class_in_program29 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _EOF_in_program33 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CLASS_in_class42 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _WS_in_class44 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _TYPE_in_class46 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _WS_in_class48 = new BitSet(new ulong[]{0x400000080000000UL});
		public static readonly BitSet _INHERITS_in_class51 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _WS_in_class55 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _TYPE_in_class57 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _WS_in_class59 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _OP_CORCH_in_class61 = new BitSet(new ulong[]{0x400040000000400UL});
		public static readonly BitSet _wsnl_in_class64 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _feature_list_in_class66 = new BitSet(new ulong[]{0x400040000000400UL});
		public static readonly BitSet _wsnl_in_class70 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _CL_CORCH_in_class73 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _END_in_class75 = new BitSet(new ulong[]{0x400040000000000UL});
		public static readonly BitSet _wsnl_in_class77 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _feature_in_feature_list87 = new BitSet(new ulong[]{0x400040000000002UL});
		public static readonly BitSet _wsnl_in_feature_list90 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _feature_in_feature_list92 = new BitSet(new ulong[]{0x400040000000002UL});
		public static readonly BitSet _ID_in_feature102 = new BitSet(new ulong[]{0x401000000010000UL});
		public static readonly BitSet _WS_in_feature105 = new BitSet(new ulong[]{0x1000000010000UL});
		public static readonly BitSet _attribute_in_feature110 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _methodefinition_in_feature112 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _END_in_feature115 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOUBLEP_in_attribute125 = new BitSet(new ulong[]{0x440000000000000UL});
		public static readonly BitSet _WS_in_attribute128 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _TYPE_in_attribute132 = new BitSet(new ulong[]{0x400000000000022UL});
		public static readonly BitSet _WS_in_attribute136 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSING_in_attribute140 = new BitSet(new ulong[]{0x6018B0918000080UL});
		public static readonly BitSet _WS_in_attribute143 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_attribute147 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_PARENT_in_methodefinition159 = new BitSet(new ulong[]{0x400000008000800UL});
		public static readonly BitSet _WS_in_methodefinition163 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _params_list_in_methodefinition167 = new BitSet(new ulong[]{0x400000000000800UL});
		public static readonly BitSet _WS_in_methodefinition172 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _CL_PARENT_in_methodefinition176 = new BitSet(new ulong[]{0x400000000010000UL});
		public static readonly BitSet _WS_in_methodefinition179 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _DOUBLEP_in_methodefinition183 = new BitSet(new ulong[]{0x440000000000000UL});
		public static readonly BitSet _WS_in_methodefinition186 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _TYPE_in_methodefinition190 = new BitSet(new ulong[]{0x400800000000000UL});
		public static readonly BitSet _WS_in_methodefinition193 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _OP_CORCH_in_methodefinition197 = new BitSet(new ulong[]{0x6018F0918000080UL});
		public static readonly BitSet _wsnl_in_methodefinition200 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_methodefinition204 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _CL_CORCH_in_methodefinition207 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _param_in_params_list215 = new BitSet(new ulong[]{0x400000000001002UL});
		public static readonly BitSet _WS_in_params_list219 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _COMA_in_params_list223 = new BitSet(new ulong[]{0x400000008000000UL});
		public static readonly BitSet _WS_in_params_list226 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _param_in_params_list230 = new BitSet(new ulong[]{0x400000000001002UL});
		public static readonly BitSet _ID_in_param239 = new BitSet(new ulong[]{0x400000000010000UL});
		public static readonly BitSet _WS_in_param242 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _DOUBLEP_in_param246 = new BitSet(new ulong[]{0x440000000000000UL});
		public static readonly BitSet _WS_in_param249 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _TYPE_in_param253 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignment_in_expr261 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionals_in_expr268 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _loops_in_expr275 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _blocks_in_expr282 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _let_in_expr289 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _case_in_expr296 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _new_in_expr303 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operations_in_expr310 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assignment337 = new BitSet(new ulong[]{0x400000000000020UL});
		public static readonly BitSet _WS_in_assignment340 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSING_in_assignment344 = new BitSet(new ulong[]{0x6018B0918000080UL});
		public static readonly BitSet _WS_in_assignment347 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_assignment351 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_conditionals359 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _WS_in_conditionals361 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_conditionals363 = new BitSet(new ulong[]{0x400040000000000UL});
		public static readonly BitSet _wsnl_in_conditionals365 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _THEN_in_conditionals367 = new BitSet(new ulong[]{0x400040000000000UL});
		public static readonly BitSet _wsnl_in_conditionals369 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_conditionals371 = new BitSet(new ulong[]{0x400040000000000UL});
		public static readonly BitSet _wsnl_in_conditionals373 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _FI_in_conditionals375 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_loops383 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _WS_in_loops385 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_loops387 = new BitSet(new ulong[]{0x400040000000000UL});
		public static readonly BitSet _wsnl_in_loops389 = new BitSet(new ulong[]{0x1000000000UL});
		public static readonly BitSet _LOOP_in_loops391 = new BitSet(new ulong[]{0x400040000000000UL});
		public static readonly BitSet _wsnl_in_loops393 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_loops395 = new BitSet(new ulong[]{0x400040000000000UL});
		public static readonly BitSet _wsnl_in_loops397 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _POOL_in_loops399 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_CORCH_in_blocks407 = new BitSet(new ulong[]{0x6018F0918000480UL});
		public static readonly BitSet _wsnl_in_blocks411 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_blocks415 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _END_in_blocks417 = new BitSet(new ulong[]{0x6018F0918000480UL});
		public static readonly BitSet _wsnl_in_blocks420 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_blocks423 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _END_in_blocks425 = new BitSet(new ulong[]{0x6018F0918000480UL});
		public static readonly BitSet _wsnl_in_blocks432 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _CL_CORCH_in_blocks436 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LET_in_let444 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _WS_in_let446 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _assignment_in_let448 = new BitSet(new ulong[]{0x400040000001000UL});
		public static readonly BitSet _WS_in_let453 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _COMA_in_let457 = new BitSet(new ulong[]{0x400000008000000UL});
		public static readonly BitSet _WS_in_let460 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _assignment_in_let464 = new BitSet(new ulong[]{0x400040000001000UL});
		public static readonly BitSet _wsnl_in_let468 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _IN_in_let470 = new BitSet(new ulong[]{0x400040000000000UL});
		public static readonly BitSet _wsnl_in_let472 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_let474 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_case482 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _WS_in_case484 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_case486 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _WS_in_case488 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _OF_in_case490 = new BitSet(new ulong[]{0x400040000000000UL});
		public static readonly BitSet _wsnl_in_case493 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _param_in_case495 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _WS_in_case497 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _IMPLICS_in_case499 = new BitSet(new ulong[]{0x400040000000000UL});
		public static readonly BitSet _wsnl_in_case501 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_case503 = new BitSet(new ulong[]{0x400040000000000UL});
		public static readonly BitSet _wsnl_in_case507 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _ESAC_in_case509 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_new518 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _WS_in_new520 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _TYPE_in_new522 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ARROBA_in_dispatch533 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _TYPE_in_dispatch535 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _PNT_in_dispatch538 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _ID_in_dispatch541 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _OP_PARENT_in_dispatch543 = new BitSet(new ulong[]{0x6018B0918000880UL});
		public static readonly BitSet _WS_in_dispatch545 = new BitSet(new ulong[]{0x2018B0918000880UL});
		public static readonly BitSet _expr_in_dispatch549 = new BitSet(new ulong[]{0x400000000001800UL});
		public static readonly BitSet _WS_in_dispatch552 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _COMA_in_dispatch555 = new BitSet(new ulong[]{0x6018B0918000080UL});
		public static readonly BitSet _WS_in_dispatch557 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_dispatch560 = new BitSet(new ulong[]{0x400000000001800UL});
		public static readonly BitSet _CL_PARENT_in_dispatch566 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_operations581 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_operations583 = new BitSet(new ulong[]{0x1010108000000UL});
		public static readonly BitSet _lv1_in_operations587 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lv2_in_lv1597 = new BitSet(new ulong[]{0x400000603080002UL});
		public static readonly BitSet _WS_in_lv1601 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _LEQ_in_lv1605 = new BitSet(new ulong[]{0x401010108000000UL});
		public static readonly BitSet _WS_in_lv1608 = new BitSet(new ulong[]{0x1010108000000UL});
		public static readonly BitSet _lv1_in_lv1612 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GEQ_in_lv1614 = new BitSet(new ulong[]{0x401010108000000UL});
		public static readonly BitSet _WS_in_lv1617 = new BitSet(new ulong[]{0x1010108000000UL});
		public static readonly BitSet _lv1_in_lv1621 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _L_in_lv1623 = new BitSet(new ulong[]{0x401010108000000UL});
		public static readonly BitSet _WS_in_lv1626 = new BitSet(new ulong[]{0x1010108000000UL});
		public static readonly BitSet _lv1_in_lv1630 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _G_in_lv1632 = new BitSet(new ulong[]{0x401010108000000UL});
		public static readonly BitSet _WS_in_lv1635 = new BitSet(new ulong[]{0x1010108000000UL});
		public static readonly BitSet _lv1_in_lv1639 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EQ_in_lv1641 = new BitSet(new ulong[]{0x401010108000000UL});
		public static readonly BitSet _WS_in_lv1644 = new BitSet(new ulong[]{0x1010108000000UL});
		public static readonly BitSet _lv1_in_lv1648 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lv3_in_lv2658 = new BitSet(new ulong[]{0x402004000000002UL});
		public static readonly BitSet _WS_in_lv2662 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _PLUS_in_lv2666 = new BitSet(new ulong[]{0x401010108000000UL});
		public static readonly BitSet _WS_in_lv2669 = new BitSet(new ulong[]{0x1010108000000UL});
		public static readonly BitSet _lv2_in_lv2673 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_lv2675 = new BitSet(new ulong[]{0x401010108000000UL});
		public static readonly BitSet _WS_in_lv2678 = new BitSet(new ulong[]{0x1010108000000UL});
		public static readonly BitSet _lv2_in_lv2682 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lv4_in_lv3693 = new BitSet(new ulong[]{0x400008000008002UL});
		public static readonly BitSet _WS_in_lv3696 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _MULT_in_lv3700 = new BitSet(new ulong[]{0x401010108000000UL});
		public static readonly BitSet _WS_in_lv3703 = new BitSet(new ulong[]{0x1010108000000UL});
		public static readonly BitSet _lv3_in_lv3707 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DIV_in_lv3709 = new BitSet(new ulong[]{0x401010108000000UL});
		public static readonly BitSet _WS_in_lv3712 = new BitSet(new ulong[]{0x1010108000000UL});
		public static readonly BitSet _lv3_in_lv3716 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ISVOID_in_lv4727 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _WS_in_lv4729 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_lv4731 = new BitSet(new ulong[]{0x1010008000000UL});
		public static readonly BitSet _lv5_in_lv4734 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nanarita_in_lv5743 = new BitSet(new ulong[]{0x1000008000000UL});
		public static readonly BitSet _lv6_in_lv5746 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_lv6756 = new BitSet(new ulong[]{0x4000000000012UL});
		public static readonly BitSet _OP_PARENT_in_lv6758 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_lv6760 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _CL_PARENT_in_lv6762 = new BitSet(new ulong[]{0x4000000000012UL});
		public static readonly BitSet _dispatch_in_lv6765 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NANARITA_in_nanarita778 = new BitSet(new ulong[]{0x2018B0918000080UL});
		public static readonly BitSet _expr_in_nanarita780 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOF_in_compileUnit803 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
